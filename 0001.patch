From b9e41c03cd447bc9313a0249f548e9445f0776c1 Mon Sep 17 00:00:00 2001
From: sic <sic@qti.qualcomm.com>
Date: Wed, 2 Aug 2023 19:02:45 +0800
Subject: [PATCH] #Add: add vk_khr_deferred_host_operations

---
 .../pyrenderdoc/pyrenderdoc_module.vcxproj    |   11 +-
 .../pyrenderdoc_module.vcxproj.filters        |    2 +-
 .../pyrenderdoc/qrenderdoc_module.vcxproj     |    3 +-
 qrenderdoc/qrenderdoc_local.vcxproj           |    3 +-
 qrenderdoc/renderdocui_stub.vcxproj           |    3 +-
 .../breakpad/client/windows/common.vcxproj    |    9 +-
 .../crash_generation_client.vcxproj           |    9 +-
 .../crash_generation_server.vcxproj           |    9 +-
 .../windows/handler/exception_handler.vcxproj |    9 +-
 .../driver/d3d11/renderdoc_d3d11.vcxproj      |    3 +-
 .../driver/d3d12/renderdoc_d3d12.vcxproj      |    3 +-
 renderdoc/driver/dxgi/renderdoc_dxgi.vcxproj  |    3 +-
 renderdoc/driver/gl/renderdoc_gl.vcxproj      |    3 +-
 renderdoc/driver/ihv/amd/AMD.vcxproj          |    5 +-
 renderdoc/driver/ihv/arm/ARM.vcxproj          |    3 +-
 renderdoc/driver/ihv/intel/Intel.vcxproj      |    3 +-
 renderdoc/driver/ihv/nv/NV.vcxproj            |    3 +-
 renderdoc/driver/ihv/nv/NV.vcxproj.filters    |  115 +-
 .../shaders/dxbc/renderdoc_dxbc.vcxproj       |    3 +-
 .../shaders/dxil/renderdoc_dxil.vcxproj       |    3 +-
 .../shaders/spirv/renderdoc_spirv.vcxproj     |    3 +-
 .../driver/vulkan/official/vulkan_core.h      |   94 +-
 .../driver/vulkan/renderdoc_vulkan.vcxproj    |    3 +-
 renderdoc/driver/vulkan/vk_common.h           |   71 +-
 renderdoc/driver/vulkan/vk_core.cpp           |   81 ++
 renderdoc/driver/vulkan/vk_core.h             |   94 ++
 renderdoc/driver/vulkan/vk_hookset_defs.h     |   88 +-
 renderdoc/driver/vulkan/vk_manager.h          |    8 +-
 renderdoc/driver/vulkan/vk_next_chains.cpp    |  308 ++--
 renderdoc/driver/vulkan/vk_resources.cpp      |    6 +
 renderdoc/driver/vulkan/vk_resources.h        |   32 +-
 renderdoc/driver/vulkan/vk_serialise.cpp      |  348 ++++-
 renderdoc/driver/vulkan/vk_stringise.cpp      |   80 +-
 .../vulkan/wrappers/vk_device_funcs.cpp       |   18 +
 .../driver/vulkan/wrappers/vk_misc_funcs.cpp  | 1279 +++++++++++++++--
 renderdoc/renderdoc.vcxproj                   |    3 +-
 renderdoc/renderdoc_version.vcxproj           |   25 +-
 renderdoccmd/renderdoccmd.vcxproj             |    9 +-
 renderdocshim/renderdocshim.vcxproj           |    9 +-
 39 files changed, 2203 insertions(+), 561 deletions(-)

diff --git a/qrenderdoc/Code/pyrenderdoc/pyrenderdoc_module.vcxproj b/qrenderdoc/Code/pyrenderdoc/pyrenderdoc_module.vcxproj
index 1d822a7f4..2e75a10e8 100644
--- a/qrenderdoc/Code/pyrenderdoc/pyrenderdoc_module.vcxproj
+++ b/qrenderdoc/Code/pyrenderdoc/pyrenderdoc_module.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>pyrenderdoc_module</RootNamespace>
     <ProjectName>pyrenderdoc_module</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -32,28 +33,28 @@
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Development|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Development|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
@@ -159,4 +160,4 @@
     </ProjectReference>
   </ItemGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-</Project>
+</Project>
\ No newline at end of file
diff --git a/qrenderdoc/Code/pyrenderdoc/pyrenderdoc_module.vcxproj.filters b/qrenderdoc/Code/pyrenderdoc/pyrenderdoc_module.vcxproj.filters
index cab872e18..51776c8b7 100644
--- a/qrenderdoc/Code/pyrenderdoc/pyrenderdoc_module.vcxproj.filters
+++ b/qrenderdoc/Code/pyrenderdoc/pyrenderdoc_module.vcxproj.filters
@@ -4,7 +4,7 @@
     <CustomBuild Include="renderdoc.i" />
   </ItemGroup>
   <ItemGroup>
-    <ClCompile Include="$(IntDir)generated\renderdoc_python.cxx" />
     <ClCompile Include="pyrenderdoc_stub.cpp" />
+    <ClCompile Include="$(IntDir)generated\renderdoc_module_python.cxx" />
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/qrenderdoc/Code/pyrenderdoc/qrenderdoc_module.vcxproj b/qrenderdoc/Code/pyrenderdoc/qrenderdoc_module.vcxproj
index c105360c1..5a269fd82 100644
--- a/qrenderdoc/Code/pyrenderdoc/qrenderdoc_module.vcxproj
+++ b/qrenderdoc/Code/pyrenderdoc/qrenderdoc_module.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>qrenderdoc_module</RootNamespace>
     <ProjectName>qrenderdoc_module</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -32,7 +33,7 @@
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
diff --git a/qrenderdoc/qrenderdoc_local.vcxproj b/qrenderdoc/qrenderdoc_local.vcxproj
index 69e70f376..f55aa04dc 100644
--- a/qrenderdoc/qrenderdoc_local.vcxproj
+++ b/qrenderdoc/qrenderdoc_local.vcxproj
@@ -31,12 +31,13 @@
     <RootNamespace>qrenderdoc</RootNamespace>
     <Keyword>Qt4VSv1.0</Keyword>
     <ProjectName>qrenderdoc</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <Import Project="$(SolutionDir)\qrenderdoc\Code\pyrenderdoc\python.props" />
   <PropertyGroup>
-    <PlatformToolSet>v140</PlatformToolSet>
+    <PlatformToolSet>v143</PlatformToolSet>
     <OutputDirectory>$(SolutionDir)$(Platform)\$(Configuration)\</OutputDirectory>
     <ATLMinimizesCRunTimeLibraryUsage>false</ATLMinimizesCRunTimeLibraryUsage>
     <CharacterSet>NotSet</CharacterSet>
diff --git a/qrenderdoc/renderdocui_stub.vcxproj b/qrenderdoc/renderdocui_stub.vcxproj
index 3d7406945..c3e3d7349 100644
--- a/qrenderdoc/renderdocui_stub.vcxproj
+++ b/qrenderdoc/renderdocui_stub.vcxproj
@@ -23,13 +23,14 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdocui_stub</RootNamespace>
     <ProjectName>renderdocui_stub</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup>
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
     <OutputDirectory>$(SolutionDir)$(Platform)\$(Configuration)\</OutputDirectory>
     <SolutionRelativeIntDir>$(Platform)\$(Configuration)\obj\$(ProjectName)\</SolutionRelativeIntDir>
     <CharacterSet>Unicode</CharacterSet>
diff --git a/renderdoc/3rdparty/breakpad/client/windows/common.vcxproj b/renderdoc/3rdparty/breakpad/client/windows/common.vcxproj
index e7826345c..94b359dfb 100644
--- a/renderdoc/3rdparty/breakpad/client/windows/common.vcxproj
+++ b/renderdoc/3rdparty/breakpad/client/windows/common.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>common</RootNamespace>
     <ProjectName>breakpad_common</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -31,16 +32,16 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Development|Win32'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Development|x64'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings" />
diff --git a/renderdoc/3rdparty/breakpad/client/windows/crash_generation/crash_generation_client.vcxproj b/renderdoc/3rdparty/breakpad/client/windows/crash_generation/crash_generation_client.vcxproj
index 5cf7242f8..fa4a2a131 100644
--- a/renderdoc/3rdparty/breakpad/client/windows/crash_generation/crash_generation_client.vcxproj
+++ b/renderdoc/3rdparty/breakpad/client/windows/crash_generation/crash_generation_client.vcxproj
@@ -22,6 +22,7 @@
     <ProjectGuid>{EC847717-119A-2391-0477-212E1140082C}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>crash_generation_client</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,16 +31,16 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Development|Win32'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Development|x64'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings" />
diff --git a/renderdoc/3rdparty/breakpad/client/windows/crash_generation/crash_generation_server.vcxproj b/renderdoc/3rdparty/breakpad/client/windows/crash_generation/crash_generation_server.vcxproj
index 62cd7f495..031bdd5c5 100644
--- a/renderdoc/3rdparty/breakpad/client/windows/crash_generation/crash_generation_server.vcxproj
+++ b/renderdoc/3rdparty/breakpad/client/windows/crash_generation/crash_generation_server.vcxproj
@@ -22,6 +22,7 @@
     <ProjectGuid>{7893E300-3ED0-7F4C-158F-67EA63934C57}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>crash_generation_server</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,16 +31,16 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Development|Win32'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Development|x64'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings" />
diff --git a/renderdoc/3rdparty/breakpad/client/windows/handler/exception_handler.vcxproj b/renderdoc/3rdparty/breakpad/client/windows/handler/exception_handler.vcxproj
index 236775a4e..9b97d8168 100644
--- a/renderdoc/3rdparty/breakpad/client/windows/handler/exception_handler.vcxproj
+++ b/renderdoc/3rdparty/breakpad/client/windows/handler/exception_handler.vcxproj
@@ -22,6 +22,7 @@
     <ProjectGuid>{B7399F39-300F-450E-F471-9490F959D2A7}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>exception_handler</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,16 +31,16 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Development|Win32'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Label="Configuration" Condition="'$(Configuration)|$(Platform)'=='Development|x64'">
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings" />
diff --git a/renderdoc/driver/d3d11/renderdoc_d3d11.vcxproj b/renderdoc/driver/d3d11/renderdoc_d3d11.vcxproj
index c40c35174..1e9191736 100644
--- a/renderdoc/driver/d3d11/renderdoc_d3d11.vcxproj
+++ b/renderdoc/driver/d3d11/renderdoc_d3d11.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoc_d3d11</RootNamespace>
     <ProjectName>d3d11</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,7 +31,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/d3d12/renderdoc_d3d12.vcxproj b/renderdoc/driver/d3d12/renderdoc_d3d12.vcxproj
index d4bf8c49d..24fb78803 100644
--- a/renderdoc/driver/d3d12/renderdoc_d3d12.vcxproj
+++ b/renderdoc/driver/d3d12/renderdoc_d3d12.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoc_d3d12</RootNamespace>
     <ProjectName>d3d12</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,7 +31,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/dxgi/renderdoc_dxgi.vcxproj b/renderdoc/driver/dxgi/renderdoc_dxgi.vcxproj
index a8d9b9cb1..d28403e9a 100644
--- a/renderdoc/driver/dxgi/renderdoc_dxgi.vcxproj
+++ b/renderdoc/driver/dxgi/renderdoc_dxgi.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoc_dxgi</RootNamespace>
     <ProjectName>dxgi</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,7 +31,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/gl/renderdoc_gl.vcxproj b/renderdoc/driver/gl/renderdoc_gl.vcxproj
index fd5360682..fd329f3a9 100644
--- a/renderdoc/driver/gl/renderdoc_gl.vcxproj
+++ b/renderdoc/driver/gl/renderdoc_gl.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoc_gl</RootNamespace>
     <ProjectName>gl</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,7 +31,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/ihv/amd/AMD.vcxproj b/renderdoc/driver/ihv/amd/AMD.vcxproj
index b7b87396e..59a40a188 100644
--- a/renderdoc/driver/ihv/amd/AMD.vcxproj
+++ b/renderdoc/driver/ihv/amd/AMD.vcxproj
@@ -21,6 +21,7 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{5DE5A561-548A-4DD7-90F0-06A2B39EAE9A}</ProjectGuid>
     <RootNamespace>AMD</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -28,7 +29,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
@@ -140,4 +141,4 @@
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
+</Project>
\ No newline at end of file
diff --git a/renderdoc/driver/ihv/arm/ARM.vcxproj b/renderdoc/driver/ihv/arm/ARM.vcxproj
index 0705ce588..3547b68e5 100644
--- a/renderdoc/driver/ihv/arm/ARM.vcxproj
+++ b/renderdoc/driver/ihv/arm/ARM.vcxproj
@@ -21,6 +21,7 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{F9CCE6CA-0CA3-4A22-9C7B-881369955E62}</ProjectGuid>
     <RootNamespace>AMD</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -28,7 +29,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/ihv/intel/Intel.vcxproj b/renderdoc/driver/ihv/intel/Intel.vcxproj
index 91408f273..d8d4f183a 100644
--- a/renderdoc/driver/ihv/intel/Intel.vcxproj
+++ b/renderdoc/driver/ihv/intel/Intel.vcxproj
@@ -21,6 +21,7 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{7FCB5FC5-1DBD-4DA6-83A0-6BA4E945BDA5}</ProjectGuid>
     <RootNamespace>Intel</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -28,7 +29,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/ihv/nv/NV.vcxproj b/renderdoc/driver/ihv/nv/NV.vcxproj
index 0cf6178d0..3d6209c97 100644
--- a/renderdoc/driver/ihv/nv/NV.vcxproj
+++ b/renderdoc/driver/ihv/nv/NV.vcxproj
@@ -21,6 +21,7 @@
   <PropertyGroup Label="Globals">
     <ProjectGuid>{40349AD9-5558-4DF4-84E2-11934DE90A11}</ProjectGuid>
     <RootNamespace>NV</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -28,7 +29,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/ihv/nv/NV.vcxproj.filters b/renderdoc/driver/ihv/nv/NV.vcxproj.filters
index eb5dc6aba..a87ca40ce 100644
--- a/renderdoc/driver/ihv/nv/NV.vcxproj.filters
+++ b/renderdoc/driver/ihv/nv/NV.vcxproj.filters
@@ -16,111 +16,11 @@
     <ClInclude Include="nvapi_wrapper.h">
       <Filter>nvapi</Filter>
     </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\linux-desktop-x64\nvperf_host_impl.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_common.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_d3d11_host.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_d3d11_target.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_d3d12_host.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_d3d12_target.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_device_host.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_device_target.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_host.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_opengl_host.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_opengl_target.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_target.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_versions_target.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_vulkan_host.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\nvperf_vulkan_target.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\include\windows-desktop-x64\nvperf_host_impl.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfCounterConfiguration.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfCounterData.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfD3D.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfD3D11.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfD3D12.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfDeviceProperties.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfInit.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfMetricsConfigBuilder.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfMetricsEvaluator.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfOpenGL.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfPeriodicSamplerCommon.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfPeriodicSamplerGpu.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfRangeProfiler.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfRangeProfilerD3D11.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfRangeProfilerD3D12.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfRangeProfilerOpenGL.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfRangeProfilerVulkan.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfScopeExitGuard.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
-    <ClInclude Include="official\PerfSDK\redist\NvPerfUtility\include\NvPerfVulkan.h">
-      <Filter>official\PerfSDK</Filter>
-    </ClInclude>
+    <ClInclude Include="nv_counter_enumerator.h" />
+    <ClInclude Include="nv_d3d11_counters.h" />
+    <ClInclude Include="nv_d3d12_counters.h" />
+    <ClInclude Include="nv_gl_counters.h" />
+    <ClInclude Include="nv_vk_counters.h" />
   </ItemGroup>
   <ItemGroup>
     <Filter Include="official">
@@ -155,5 +55,10 @@
     <ClCompile Include="nvapi_wrapper.cpp">
       <Filter>nvapi</Filter>
     </ClCompile>
+    <ClCompile Include="nv_counter_enumerator.cpp" />
+    <ClCompile Include="nv_d3d11_counters.cpp" />
+    <ClCompile Include="nv_d3d12_counters.cpp" />
+    <ClCompile Include="nv_gl_counters.cpp" />
+    <ClCompile Include="nv_vk_counters.cpp" />
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/renderdoc/driver/shaders/dxbc/renderdoc_dxbc.vcxproj b/renderdoc/driver/shaders/dxbc/renderdoc_dxbc.vcxproj
index f4e005c92..624edd453 100644
--- a/renderdoc/driver/shaders/dxbc/renderdoc_dxbc.vcxproj
+++ b/renderdoc/driver/shaders/dxbc/renderdoc_dxbc.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoc_dxbc</RootNamespace>
     <ProjectName>dxbc</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,7 +31,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/shaders/dxil/renderdoc_dxil.vcxproj b/renderdoc/driver/shaders/dxil/renderdoc_dxil.vcxproj
index 54fd840d1..96d7aba8a 100644
--- a/renderdoc/driver/shaders/dxil/renderdoc_dxil.vcxproj
+++ b/renderdoc/driver/shaders/dxil/renderdoc_dxil.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoc_dxil</RootNamespace>
     <ProjectName>dxil</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,7 +31,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/shaders/spirv/renderdoc_spirv.vcxproj b/renderdoc/driver/shaders/spirv/renderdoc_spirv.vcxproj
index b3e5dbad4..457f541f1 100644
--- a/renderdoc/driver/shaders/spirv/renderdoc_spirv.vcxproj
+++ b/renderdoc/driver/shaders/spirv/renderdoc_spirv.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoc_spirv</RootNamespace>
     <ProjectName>spirv</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,7 +31,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/vulkan/official/vulkan_core.h b/renderdoc/driver/vulkan/official/vulkan_core.h
index 8d2811d26..87c076d30 100644
--- a/renderdoc/driver/vulkan/official/vulkan_core.h
+++ b/renderdoc/driver/vulkan/official/vulkan_core.h
@@ -10300,54 +10300,56 @@ typedef struct VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR {
 
 #define VK_EXT_debug_report 1
 VK_DEFINE_NON_DISPATCHABLE_HANDLE(VkDebugReportCallbackEXT)
-#define VK_EXT_DEBUG_REPORT_SPEC_VERSION  10
+#define VK_EXT_DEBUG_REPORT_SPEC_VERSION 10
 #define VK_EXT_DEBUG_REPORT_EXTENSION_NAME "VK_EXT_debug_report"
 
-typedef enum VkDebugReportObjectTypeEXT {
-    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
-    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
-    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
-    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
-    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
-    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
-    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
-    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
-    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
-    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
-    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
-    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
-    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
-    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
-    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
-    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
-    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
-    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
-    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
-    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
-    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
-    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
-    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
-    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
-    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
-    VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
-    VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
-    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
-    VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
-    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
-    VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
-    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
-    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
-    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
+typedef enum VkDebugReportObjectTypeEXT
+{
+  VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
+  VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
+  VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
+  VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
+  VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
+  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
+  VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
+  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
+  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
+  VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
+  VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
+  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
+  VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
+  VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
+  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
+  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
+  VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
+  VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
+  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
+  VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
+  VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
+  VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
+  VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
+  VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT = 33,
+  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT = 1000156000,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT = 1000085000,
+  VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT = 1000029000,
+  VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT = 1000029001,
+  VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT = 1000150000,
+  VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT = 1000165000,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DEFERRED_OPERATION_KHR = 1000268000,
+  VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT = 1000366000,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT,
+  VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT,
+  VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT,
+  VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_KHR_EXT = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT,
+  VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 0x7FFFFFFF
 } VkDebugReportObjectTypeEXT;
 
 typedef enum VkDebugReportFlagBitsEXT {
diff --git a/renderdoc/driver/vulkan/renderdoc_vulkan.vcxproj b/renderdoc/driver/vulkan/renderdoc_vulkan.vcxproj
index 1dabd623d..8aac5ac50 100644
--- a/renderdoc/driver/vulkan/renderdoc_vulkan.vcxproj
+++ b/renderdoc/driver/vulkan/renderdoc_vulkan.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoc_vulkan</RootNamespace>
     <ProjectName>vulkan</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,7 +31,7 @@
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <WholeProgramOptimization>true</WholeProgramOptimization>
diff --git a/renderdoc/driver/vulkan/vk_common.h b/renderdoc/driver/vulkan/vk_common.h
index 5e37592b8..e0aee36e6 100644
--- a/renderdoc/driver/vulkan/vk_common.h
+++ b/renderdoc/driver/vulkan/vk_common.h
@@ -926,6 +926,29 @@ enum class VulkanChunk : uint32_t
   vkCmdSetFragmentShadingRateKHR,
   vkSetDeviceMemoryPriorityEXT,
   vkCmdSetAttachmentFeedbackLoopEnableEXT,
+  // raytracing
+  vkCreateAccelerationStructureKHR,
+  vkDestroyAccelerationStructureKHR,
+  vkCmdBuildAccelerationStructuresKHR,
+  vkCmdBuildAccelerationStructuresIndirectKHR,
+  vkBuildAccelerationStructuresKHR,
+  vkCopyAccelerationStructureKHR,
+  vkCopyAccelerationStructureToMemoryKHR,
+  vkCopyMemoryToAccelerationStructureKHR,
+  vkWriteAccelerationStructuresPropertiesKHR,
+  vkCmdCopyAccelerationStructureKHR,
+  vkCmdCopyAccelerationStructureToMemoryKHR,
+  vkCmdCopyMemoryToAccelerationStructureKHR,
+  vkGetAccelerationStructureDeviceAddressKHR,
+  vkCmdWriteAccelerationStructuresPropertiesKHR,
+  vkGetDeviceAccelerationStructureCompatibilityKHR,
+  vkGetAccelerationStructureBuildSizesKHR,
+  //DeferredOperation
+  vkCreateDeferredOperationKHR,
+  vkDestroyDeferredOperationKHR,
+  vkGetDeferredOperationMaxConcurrencyKHR,
+  vkGetDeferredOperationResultKHR,
+  vkDeferredOperationJoinKHR,
   Max,
 };
 
@@ -964,7 +987,10 @@ DECLARE_REFLECTION_ENUM(VulkanChunk);
   SERIALISE_HANDLE(VkSwapchainKHR)             \
   SERIALISE_HANDLE(VkSurfaceKHR)               \
   SERIALISE_HANDLE(VkDescriptorUpdateTemplate) \
-  SERIALISE_HANDLE(VkSamplerYcbcrConversion)
+  SERIALISE_HANDLE(VkSamplerYcbcrConversion)   \
+  SERIALISE_HANDLE(VkAccelerationStructureKHR)  \
+  SERIALISE_HANDLE(VkDeferredOperationKHR)  \
+
 
 #define SERIALISE_HANDLE(type) DECLARE_REFLECTION_STRUCT(type)
 
@@ -1387,6 +1413,24 @@ DECLARE_REFLECTION_STRUCT(VkVertexInputBindingDescription2EXT);
 DECLARE_REFLECTION_STRUCT(VkWriteDescriptorSet);
 DECLARE_REFLECTION_STRUCT(VkWriteDescriptorSetInlineUniformBlock);
 
+// raytracing
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureBuildRangeInfoKHR);
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureGeometryTrianglesDataKHR);
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureGeometryAabbsDataKHR);
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureGeometryInstancesDataKHR);
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureGeometryKHR);
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureBuildGeometryInfoKHR);
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureCreateInfoKHR);
+DECLARE_REFLECTION_STRUCT(VkWriteDescriptorSetAccelerationStructureKHR);
+DECLARE_REFLECTION_STRUCT(VkPhysicalDeviceAccelerationStructureFeaturesKHR);
+DECLARE_REFLECTION_STRUCT(VkPhysicalDeviceAccelerationStructurePropertiesKHR);
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureDeviceAddressInfoKHR);
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureVersionInfoKHR);
+DECLARE_REFLECTION_STRUCT(VkCopyAccelerationStructureToMemoryInfoKHR);
+DECLARE_REFLECTION_STRUCT(VkCopyMemoryToAccelerationStructureInfoKHR);
+DECLARE_REFLECTION_STRUCT(VkCopyAccelerationStructureInfoKHR);
+DECLARE_REFLECTION_STRUCT(VkAccelerationStructureBuildSizesInfoKHR);
+
 DECLARE_DESERIALISE_TYPE(VkAcquireNextImageInfoKHR);
 DECLARE_DESERIALISE_TYPE(VkAcquireProfilingLockInfoKHR);
 DECLARE_DESERIALISE_TYPE(VkApplicationInfo);
@@ -1792,6 +1836,25 @@ DECLARE_DESERIALISE_TYPE(VkVertexInputBindingDescription2EXT);
 DECLARE_DESERIALISE_TYPE(VkWriteDescriptorSet);
 DECLARE_DESERIALISE_TYPE(VkWriteDescriptorSetInlineUniformBlock);
 
+// raytracing
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureBuildRangeInfoKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureGeometryTrianglesDataKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureGeometryAabbsDataKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureGeometryInstancesDataKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureGeometryDataKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureGeometryKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureBuildGeometryInfoKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureCreateInfoKHR);
+DECLARE_DESERIALISE_TYPE(VkWriteDescriptorSetAccelerationStructureKHR);
+DECLARE_DESERIALISE_TYPE(VkPhysicalDeviceAccelerationStructureFeaturesKHR);
+DECLARE_DESERIALISE_TYPE(VkPhysicalDeviceAccelerationStructurePropertiesKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureDeviceAddressInfoKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureVersionInfoKHR);
+DECLARE_DESERIALISE_TYPE(VkCopyAccelerationStructureToMemoryInfoKHR);
+DECLARE_DESERIALISE_TYPE(VkCopyMemoryToAccelerationStructureInfoKHR);
+DECLARE_DESERIALISE_TYPE(VkCopyAccelerationStructureInfoKHR);
+DECLARE_DESERIALISE_TYPE(VkAccelerationStructureBuildSizesInfoKHR);
+
 // plain structs with no next chain
 DECLARE_REFLECTION_STRUCT(VkAllocationCallbacks);
 DECLARE_REFLECTION_STRUCT(VkAttachmentDescription);
@@ -2109,6 +2172,12 @@ DECLARE_REFLECTION_ENUM(VkValidationFeatureDisableEXT);
 DECLARE_REFLECTION_ENUM(VkValidationFeatureEnableEXT);
 DECLARE_REFLECTION_ENUM(VkVertexInputRate);
 
+// raytracing
+DECLARE_REFLECTION_ENUM(VkAccelerationStructureCreateFlagBitsKHR);
+DECLARE_REFLECTION_ENUM(VkBuildAccelerationStructureModeKHR);
+DECLARE_REFLECTION_ENUM(VkBuildAccelerationStructureFlagBitsKHR);
+DECLARE_REFLECTION_ENUM(VkGeometryFlagBitsKHR);
+
 // win32 only enums
 #ifdef VK_USE_PLATFORM_WIN32_KHR
 DECLARE_REFLECTION_ENUM(VkFullScreenExclusiveEXT);
diff --git a/renderdoc/driver/vulkan/vk_core.cpp b/renderdoc/driver/vulkan/vk_core.cpp
index f7a8f9009..e73d52b58 100644
--- a/renderdoc/driver/vulkan/vk_core.cpp
+++ b/renderdoc/driver/vulkan/vk_core.cpp
@@ -1561,6 +1561,13 @@ static const VkExtensionProperties supportedExtensions[] = {
     {
         VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_EXTENSION_NAME, VK_VALVE_MUTABLE_DESCRIPTOR_TYPE_SPEC_VERSION,
     },
+    // raytracing
+    {
+        VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME, VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION,
+    },    
+    {
+        VK_KHR_ACCELERATION_STRUCTURE_EXTENSION_NAME, VK_KHR_ACCELERATION_STRUCTURE_SPEC_VERSION,
+    },
 };
 
 // this is the list of extensions we provide - regardless of whether the ICD supports them
@@ -3728,6 +3735,80 @@ bool WrappedVulkan::ProcessChunk(ReadSerialiser &ser, VulkanChunk chunk)
     case VulkanChunk::vkCmdSetAttachmentFeedbackLoopEnableEXT:
       return Serialise_vkCmdSetAttachmentFeedbackLoopEnableEXT(ser, VK_NULL_HANDLE,
                                                                VK_IMAGE_ASPECT_NONE);
+      //raytracing
+    case VulkanChunk::vkCreateAccelerationStructureKHR:
+      return Serialise_vkCreateAccelerationStructureKHR(ser, VK_NULL_HANDLE, NULL, NULL, NULL);
+
+    case VulkanChunk::vkDestroyAccelerationStructureKHR:
+      return Serialise_vkDestroyAccelerationStructureKHR(ser, VK_NULL_HANDLE, VK_NULL_HANDLE, NULL);
+
+    case VulkanChunk::vkCmdBuildAccelerationStructuresKHR:
+      return Serialise_vkCmdBuildAccelerationStructuresKHR(ser, VK_NULL_HANDLE, 0, NULL, NULL);
+
+    case VulkanChunk::vkCmdBuildAccelerationStructuresIndirectKHR:
+      return Serialise_vkCmdBuildAccelerationStructuresIndirectKHR(ser, VK_NULL_HANDLE, 0, NULL,
+                                                                   NULL, NULL, NULL);
+
+    case VulkanChunk::vkBuildAccelerationStructuresKHR:
+      return Serialise_vkBuildAccelerationStructuresKHR(ser, VK_NULL_HANDLE, VK_NULL_HANDLE, 0, NULL,
+                                                        NULL);
+
+    case VulkanChunk::vkCopyAccelerationStructureKHR:
+      return Serialise_vkCopyAccelerationStructureKHR(ser, VK_NULL_HANDLE, VK_NULL_HANDLE, NULL);
+
+    case VulkanChunk::vkCopyAccelerationStructureToMemoryKHR:
+      return Serialise_vkCopyAccelerationStructureToMemoryKHR(ser, VK_NULL_HANDLE, VK_NULL_HANDLE,
+                                                              NULL);
+
+    case VulkanChunk::vkCopyMemoryToAccelerationStructureKHR:
+      return Serialise_vkCopyMemoryToAccelerationStructureKHR(ser, VK_NULL_HANDLE, VK_NULL_HANDLE,
+                                                              NULL);
+
+    case VulkanChunk::vkWriteAccelerationStructuresPropertiesKHR:
+      return Serialise_vkWriteAccelerationStructuresPropertiesKHR(
+          ser, VK_NULL_HANDLE, 0, NULL, VkQueryType::VK_QUERY_TYPE_MAX_ENUM, 0, NULL, 0);
+
+    case VulkanChunk::vkCmdCopyAccelerationStructureKHR:
+      return Serialise_vkCmdCopyAccelerationStructureKHR(ser, VK_NULL_HANDLE, NULL);
+
+    case VulkanChunk::vkCmdCopyAccelerationStructureToMemoryKHR:
+      return Serialise_vkCmdCopyAccelerationStructureToMemoryKHR(ser, VK_NULL_HANDLE, NULL);
+
+    case VulkanChunk::vkCmdCopyMemoryToAccelerationStructureKHR:
+      return Serialise_vkCmdCopyMemoryToAccelerationStructureKHR(ser, VK_NULL_HANDLE, NULL);
+
+    case VulkanChunk::vkGetAccelerationStructureDeviceAddressKHR:
+      return Serialise_vkGetAccelerationStructureDeviceAddressKHR(ser, VK_NULL_HANDLE, NULL);
+
+    case VulkanChunk::vkCmdWriteAccelerationStructuresPropertiesKHR:
+      return Serialise_vkCmdWriteAccelerationStructuresPropertiesKHR(ser, VK_NULL_HANDLE, 0, NULL,
+                                                                     VK_QUERY_TYPE_MAX_ENUM, 0, 0);
+
+    case VulkanChunk::vkGetDeviceAccelerationStructureCompatibilityKHR:
+      return Serialise_vkGetDeviceAccelerationStructureCompatibilityKHR(ser, VK_NULL_HANDLE, NULL,
+                                                                        NULL);
+
+    case VulkanChunk::vkGetAccelerationStructureBuildSizesKHR:
+      return Serialise_vkGetAccelerationStructureBuildSizesKHR(
+          ser, VK_NULL_HANDLE, VK_ACCELERATION_STRUCTURE_BUILD_TYPE_MAX_ENUM_KHR, NULL, NULL, NULL);
+
+      //VK_KHR_deferred_host_operations
+    case VulkanChunk::vkCreateDeferredOperationKHR:
+      return Serialise_vkCreateDeferredOperationKHR(
+          ser, VK_NULL_HANDLE, NULL, NULL);
+
+       case VulkanChunk::vkDestroyDeferredOperationKHR:
+      return Serialise_vkCreateDeferredOperationKHR(
+          ser, VK_NULL_HANDLE, NULL, NULL);
+
+        case VulkanChunk::vkGetDeferredOperationMaxConcurrencyKHR:
+      return Serialise_vkGetDeferredOperationMaxConcurrencyKHR(ser, VK_NULL_HANDLE, VK_NULL_HANDLE);
+
+        case VulkanChunk::vkGetDeferredOperationResultKHR:
+      return Serialise_vkGetDeferredOperationResultKHR(ser, VK_NULL_HANDLE, VK_NULL_HANDLE);
+
+        case VulkanChunk::vkDeferredOperationJoinKHR:
+      return Serialise_vkDeferredOperationJoinKHR(ser, VK_NULL_HANDLE, VK_NULL_HANDLE);
 
     // chunks that are reserved but not yet serialised
     case VulkanChunk::vkResetCommandPool:
diff --git a/renderdoc/driver/vulkan/vk_core.h b/renderdoc/driver/vulkan/vk_core.h
index 128311973..92bb52c43 100644
--- a/renderdoc/driver/vulkan/vk_core.h
+++ b/renderdoc/driver/vulkan/vk_core.h
@@ -2639,4 +2639,98 @@ public:
   // VK_EXT_attachment_feedback_loop_dynamic_state
   IMPLEMENT_FUNCTION_SERIALISED(void, vkCmdSetAttachmentFeedbackLoopEnableEXT,
                                 VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask);
+ //VK_KHR_acceleration_structure
+  IMPLEMENT_FUNCTION_SERIALISED(VkResult, vkCreateAccelerationStructureKHR, VkDevice device,
+                                const VkAccelerationStructureCreateInfoKHR *pCreateInfo,
+                                const VkAllocationCallbacks *pAllocator,
+                                VkAccelerationStructureKHR *pAccelerationStructure);
+
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkDestroyAccelerationStructureKHR, VkDevice device,
+                                VkAccelerationStructureKHR accelerationStructure,
+                                const VkAllocationCallbacks *pAllocator);
+
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkCmdBuildAccelerationStructuresKHR,
+                                VkCommandBuffer commandBuffer, uint32_t infoCount,
+                                const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
+                                const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos);
+
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkCmdBuildAccelerationStructuresIndirectKHR,
+                                VkCommandBuffer commandBuffer, uint32_t infoCount,
+                                const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
+                                const VkDeviceAddress *pIndirectDeviceAddresses,
+                                const uint32_t *pIndirectStrides,
+                                const uint32_t *const *ppMaxPrimitiveCounts);
+
+  IMPLEMENT_FUNCTION_SERIALISED(VkResult, vkBuildAccelerationStructuresKHR, VkDevice device,
+                                VkDeferredOperationKHR deferredOperation, uint32_t infoCount,
+                                const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
+                                const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos);
+
+  IMPLEMENT_FUNCTION_SERIALISED(VkResult, vkCopyAccelerationStructureKHR, VkDevice device,
+                                VkDeferredOperationKHR deferredOperation,
+                                const VkCopyAccelerationStructureInfoKHR *pInfo);
+
+  IMPLEMENT_FUNCTION_SERIALISED(VkResult, vkCopyAccelerationStructureToMemoryKHR, VkDevice device,
+                                VkDeferredOperationKHR deferredOperation,
+                                const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo);
+
+  IMPLEMENT_FUNCTION_SERIALISED(VkResult, vkCopyMemoryToAccelerationStructureKHR, VkDevice device,
+                                VkDeferredOperationKHR deferredOperation,
+                                const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo);
+  
+  IMPLEMENT_FUNCTION_SERIALISED(VkResult, vkWriteAccelerationStructuresPropertiesKHR, VkDevice device,
+                                uint32_t accelerationStructureCount,
+                                const VkAccelerationStructureKHR *pAccelerationStructures,
+                                VkQueryType queryType, size_t dataSize, void *pData,
+                                size_t stride);
+
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkCmdCopyAccelerationStructureKHR, VkCommandBuffer commandBuffer,
+                                const VkCopyAccelerationStructureInfoKHR *pInfo);
+
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkCmdCopyAccelerationStructureToMemoryKHR,
+                                VkCommandBuffer commandBuffer,
+                                const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo);
+
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkCmdCopyMemoryToAccelerationStructureKHR,
+                                VkCommandBuffer commandBuffer,
+                                const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo);
+
+  IMPLEMENT_FUNCTION_SERIALISED(VkDeviceAddress, vkGetAccelerationStructureDeviceAddressKHR,
+                                VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo);
+
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkCmdWriteAccelerationStructuresPropertiesKHR,
+                                VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount,
+                                const VkAccelerationStructureKHR *pAccelerationStructures,
+                                VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery);
+
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkGetDeviceAccelerationStructureCompatibilityKHR,
+                                VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo,
+                                VkAccelerationStructureCompatibilityKHR *pCompatibility);
+
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkGetAccelerationStructureBuildSizesKHR, VkDevice device,
+                                VkAccelerationStructureBuildTypeKHR buildType,
+                                const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo,
+                                const uint32_t *pMaxPrimitiveCounts,  VkAccelerationStructureBuildSizesInfoKHR * pSizeInfo);
+  
+  //VK_KHR_deferred_host_operations
+  IMPLEMENT_FUNCTION_SERIALISED(VkResult, vkCreateDeferredOperationKHR, VkDevice device,
+                                const VkAllocationCallbacks *pAllocator,
+                                VkDeferredOperationKHR *pDeferredOperation);  
+  
+  IMPLEMENT_FUNCTION_SERIALISED(void, vkDestroyDeferredOperationKHR, VkDevice device,
+                                VkDeferredOperationKHR operation,
+                                const VkAllocationCallbacks *pAllocator);  
+  
+  IMPLEMENT_FUNCTION_SERIALISED(uint32_t, vkGetDeferredOperationMaxConcurrencyKHR, VkDevice device,
+                                VkDeferredOperationKHR operation);  
+  
+  IMPLEMENT_FUNCTION_SERIALISED(VkResult, vkGetDeferredOperationResultKHR, VkDevice device,
+                                VkDeferredOperationKHR operation);
+   
+  IMPLEMENT_FUNCTION_SERIALISED(VkResult, vkDeferredOperationJoinKHR, VkDevice device,
+                                VkDeferredOperationKHR operation);
+
+
+
 };
+
diff --git a/renderdoc/driver/vulkan/vk_hookset_defs.h b/renderdoc/driver/vulkan/vk_hookset_defs.h
index 7bdaedf28..eb0a17fd0 100644
--- a/renderdoc/driver/vulkan/vk_hookset_defs.h
+++ b/renderdoc/driver/vulkan/vk_hookset_defs.h
@@ -548,7 +548,9 @@
   DeclExt(EXT_pageable_device_local_memory);          \
   DeclExt(EXT_swapchain_maintenance1);                \
   DeclExt(EXT_provoking_vertex);                      \
-  DeclExt(EXT_attachment_feedback_loop_dynamic_state);
+  DeclExt(EXT_attachment_feedback_loop_dynamic_state);     \
+  DeclExt(KHR_acceleration_structure);                          
+
 
 // for simplicity and since the check itself is platform agnostic,
 // these aren't protected in platform defines
@@ -583,7 +585,9 @@
   CheckExt(KHR_wayland_surface, VKXX);                 \
   CheckExt(KHR_performance_query, VKXX);               \
   CheckExt(KHR_fragment_shading_rate, VKXX);           \
-  CheckExt(EXT_acquire_drm_display, VKXX);
+  CheckExt(EXT_acquire_drm_display, VKXX);                \
+  CheckExt(KHR_acceleration_structure, VKXX);
+
 
 #define CheckDeviceExts()                                    \
   CheckExt(EXT_debug_marker, VKXX);                          \
@@ -667,7 +671,9 @@
   CheckExt(EXT_pageable_device_local_memory, VKXX);          \
   CheckExt(EXT_swapchain_maintenance1, VKXX);                \
   CheckExt(EXT_provoking_vertex, VKXX);                      \
-  CheckExt(EXT_attachment_feedback_loop_dynamic_state, VKXX);
+  CheckExt(EXT_attachment_feedback_loop_dynamic_state, VKXX)         \
+  CheckExt(KHR_acceleration_structure, VKXX);
+
 
 #define HookInitVulkanInstanceExts_PhysDev()                                                         \
   HookInitExtension(KHR_surface, GetPhysicalDeviceSurfaceSupportKHR);                                \
@@ -931,6 +937,23 @@
   HookInitExtension(EXT_swapchain_maintenance1, ReleaseSwapchainImagesEXT);                        \
   HookInitExtension(EXT_attachment_feedback_loop_dynamic_state,                                    \
                     CmdSetAttachmentFeedbackLoopEnableEXT);                                        \
+/*raytacing*/             \
+  HookInitExtension(KHR_acceleration_structure, CreateAccelerationStructureKHR);                   \
+  HookInitExtension(KHR_acceleration_structure, DestroyAccelerationStructureKHR);                  \
+  HookInitExtension(KHR_acceleration_structure, CmdBuildAccelerationStructuresKHR);                \
+  HookInitExtension(KHR_acceleration_structure, CmdBuildAccelerationStructuresIndirectKHR);        \
+  HookInitExtension(KHR_acceleration_structure, BuildAccelerationStructuresKHR);                   \
+  HookInitExtension(KHR_acceleration_structure, CopyAccelerationStructureKHR);                     \
+  HookInitExtension(KHR_acceleration_structure, CopyAccelerationStructureToMemoryKHR);             \
+  HookInitExtension(KHR_acceleration_structure, CopyMemoryToAccelerationStructureKHR);             \
+  HookInitExtension(KHR_acceleration_structure, WriteAccelerationStructuresPropertiesKHR);         \
+  HookInitExtension(KHR_acceleration_structure, CmdCopyAccelerationStructureKHR);                  \
+  HookInitExtension(KHR_acceleration_structure, CmdCopyAccelerationStructureToMemoryKHR);          \
+  HookInitExtension(KHR_acceleration_structure, CmdCopyMemoryToAccelerationStructureKHR);          \
+  HookInitExtension(KHR_acceleration_structure, GetAccelerationStructureDeviceAddressKHR);         \
+  HookInitExtension(KHR_acceleration_structure, CmdWriteAccelerationStructuresPropertiesKHR);      \
+  HookInitExtension(KHR_acceleration_structure, GetDeviceAccelerationStructureCompatibilityKHR);   \
+  HookInitExtension(KHR_acceleration_structure, GetAccelerationStructureBuildSizesKHR);              \
   HookInitExtension_Device_Win32();                                                                \
   HookInitExtension_Device_Linux();                                                                \
   HookInitExtension_Device_GGP();                                                                  \
@@ -1659,6 +1682,65 @@
               const VkReleaseSwapchainImagesInfoEXT *, pReleaseInfo);                                \
   HookDefine2(void, vkCmdSetAttachmentFeedbackLoopEnableEXT, VkCommandBuffer, commandBuffer,         \
               VkImageAspectFlags, aspectMask);                                                       \
+  HookDefine4(VkResult, vkCreateAccelerationStructureKHR, VkDevice, device,                          \
+              const VkAccelerationStructureCreateInfoKHR *, pCreateInfo,                             \
+              const VkAllocationCallbacks *, pAllocator, VkAccelerationStructureKHR *,               \
+              pAccelerationStructure);                                                               \
+  HookDefine3(void, vkDestroyAccelerationStructureKHR, VkDevice, device, VkAccelerationStructureKHR, \
+              accelerationStructure, const VkAllocationCallbacks *, pAllocator);                     \
+  HookDefine4(void, vkCmdBuildAccelerationStructuresKHR, VkCommandBuffer, commandBuffer, uint32_t,   \
+              infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *, pInfos,                \
+              const VkAccelerationStructureBuildRangeInfoKHR *const *, ppBuildRangeInfos);           \
+  HookDefine6(void, vkCmdBuildAccelerationStructuresIndirectKHR, VkCommandBuffer, commandBuffer,     \
+              uint32_t, infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *, pInfos,      \
+              const VkDeviceAddress *, pIndirectDeviceAddresses, const uint32_t *,                   \
+              pIndirectStrides, const uint32_t *const *, ppMaxPrimitiveCounts);                      \
+  HookDefine5(VkResult, vkBuildAccelerationStructuresKHR, VkDevice, device,                          \
+              VkDeferredOperationKHR, deferredOperation, uint32_t, infoCount,                        \
+              const VkAccelerationStructureBuildGeometryInfoKHR *, pInfos,                           \
+              const VkAccelerationStructureBuildRangeInfoKHR *const *, ppBuildRangeInfos);           \
+  HookDefine3(VkResult, vkCopyAccelerationStructureKHR, VkDevice, device, VkDeferredOperationKHR,    \
+              deferredOperation, const VkCopyAccelerationStructureInfoKHR *, pInfo);                 \
+  HookDefine3(VkResult, vkCopyAccelerationStructureToMemoryKHR, VkDevice, device,                    \
+              VkDeferredOperationKHR, deferredOperation,                                             \
+              const VkCopyAccelerationStructureToMemoryInfoKHR *, pInfo);                            \
+  HookDefine3(VkResult, vkCopyMemoryToAccelerationStructureKHR, VkDevice, device,                    \
+              VkDeferredOperationKHR, deferredOperation,                                             \
+              const VkCopyMemoryToAccelerationStructureInfoKHR *, pInfo);                            \
+  HookDefine7(VkResult, vkWriteAccelerationStructuresPropertiesKHR, VkDevice, device, uint32_t,      \
+              accelerationStructureCount, const VkAccelerationStructureKHR *,                        \
+              pAccelerationStructures, VkQueryType, queryType, size_t, dataSize, void *, pData,      \
+              size_t, stride);                                                                       \
+  HookDefine2(void, vkCmdCopyAccelerationStructureKHR, VkCommandBuffer, commandBuffer,               \
+              const VkCopyAccelerationStructureInfoKHR *, pInfoo);                                   \
+  HookDefine2(void, vkCmdCopyAccelerationStructureToMemoryKHR, VkCommandBuffer, commandBuffer,       \
+              const VkCopyAccelerationStructureToMemoryInfoKHR *, pInfo);                            \
+  HookDefine2(void, vkCmdCopyMemoryToAccelerationStructureKHR, VkCommandBuffer, commandBuffer,       \
+              const VkCopyMemoryToAccelerationStructureInfoKHR *, pInfo);                            \
+  HookDefine2(VkDeviceAddress, vkGetAccelerationStructureDeviceAddressKHR, VkDevice, device,         \
+              const VkAccelerationStructureDeviceAddressInfoKHR *, pInfo);                           \
+  HookDefine6(void, vkCmdWriteAccelerationStructuresPropertiesKHR, VkCommandBuffer, commandBuffer,   \
+              uint32_t, accelerationStructureCount, const VkAccelerationStructureKHR *,              \
+              pAccelerationStructures, VkQueryType, queryType, VkQueryPool, queryPool, uint32_t,     \
+              firstQuery);                                                                           \
+  HookDefine3(void, vkGetDeviceAccelerationStructureCompatibilityKHR, VkDevice, device,              \
+              const VkAccelerationStructureVersionInfoKHR *, pVersionInfo,                           \
+              VkAccelerationStructureCompatibilityKHR *, pCompatibility);                            \
+  HookDefine5(void, vkGetAccelerationStructureBuildSizesKHR, VkDevice, device,                       \
+              VkAccelerationStructureBuildTypeKHR, buildType,                                        \
+              const VkAccelerationStructureBuildGeometryInfoKHR *, pBuildInfo, const uint32_t *,     \
+              pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *, pSizeInfo); \
+  HookDefine3(VkResult, vkCreateDeferredOperationKHR, VkDevice, device,              \
+               const VkAllocationCallbacks*, pAllocator,VkDeferredOperationKHR*, pDeferredOperation);     \
+  HookDefine3(void, vkDestroyDeferredOperationKHR, VkDevice, device,              \
+              VkDeferredOperationKHR,  operation,      \
+               const VkAllocationCallbacks *,  pAllocator);                         \
+  HookDefine2(uint32_t, vkGetDeferredOperationMaxConcurrencyKHR, VkDevice, device,              \
+              VkDeferredOperationKHR, operation);  \
+  HookDefine2(VkResult, vkGetDeferredOperationResultKHR, VkDevice, device,                   \
+              VkDeferredOperationKHR, operation);  \
+  HookDefine2(VkResult, vkDeferredOperationJoinKHR, VkDevice, device,                   \
+              VkDeferredOperationKHR, operation);  \
   HookDefine_Win32();                                                                                \
   HookDefine_Linux();                                                                                \
   HookDefine_GGP();                                                                                  \
diff --git a/renderdoc/driver/vulkan/vk_manager.h b/renderdoc/driver/vulkan/vk_manager.h
index 7d8b96475..085529643 100644
--- a/renderdoc/driver/vulkan/vk_manager.h
+++ b/renderdoc/driver/vulkan/vk_manager.h
@@ -207,15 +207,15 @@ public:
   template <typename realtype>
   realtype GetLiveHandle(ResourceId origid)
   {
-    return realtype((uint64_t)(
-        (typename UnwrapHelper<realtype>::ParentType *)ResourceManager::GetLiveResource(origid)));
+    return realtype((uint64_t)((
+        typename UnwrapHelper<realtype>::ParentType *)ResourceManager::GetLiveResource(origid)));
   }
 
   template <typename realtype>
   realtype GetCurrentHandle(ResourceId id)
   {
-    return realtype((uint64_t)(
-        (typename UnwrapHelper<realtype>::ParentType *)ResourceManager::GetCurrentResource(id)));
+    return realtype((uint64_t)((
+        typename UnwrapHelper<realtype>::ParentType *)ResourceManager::GetCurrentResource(id)));
   }
 
   // handling memory & image layouts
diff --git a/renderdoc/driver/vulkan/vk_next_chains.cpp b/renderdoc/driver/vulkan/vk_next_chains.cpp
index 38d641637..63c111aba 100644
--- a/renderdoc/driver/vulkan/vk_next_chains.cpp
+++ b/renderdoc/driver/vulkan/vk_next_chains.cpp
@@ -214,6 +214,41 @@ static void AppendModifiedChainedStruct(byte *&tempMem, VkStruct *outputStruct,
               VkPhysicalDeviceASTCDecodeFeaturesEXT);                                                \
   COPY_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT, \
               VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT);                        \
+  /*raytracing */                                                                                    \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,                     \
+              VkWriteDescriptorSetAccelerationStructureKHR);                                         \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR,                                \
+              VkCopyAccelerationStructureInfoKHR);                                                   \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,                      \
+              VkCopyAccelerationStructureToMemoryInfoKHR);                                           \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,                      \
+              VkCopyMemoryToAccelerationStructureInfoKHR);                                           \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,                 \
+              VkPhysicalDeviceAccelerationStructureFeaturesKHR);                                     \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,               \
+              VkPhysicalDeviceAccelerationStructurePropertiesKHR);                                   \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,                         \
+              VkAccelerationStructureBuildSizesInfoKHR);                                             \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR,                   \
+              VkPhysicalDeviceRayTracingPipelineFeaturesKHR);                                        \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR,                 \
+              VkPhysicalDeviceRayTracingPipelinePropertiesKHR);                                      \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,                      \
+              VkAccelerationStructureBuildGeometryInfoKHR);                                          \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,                              \
+              VkAccelerationStructureCreateInfoKHR);                                                 \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,                      \
+              VkAccelerationStructureDeviceAddressInfoKHR);                                          \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,                      \
+              VkAccelerationStructureGeometryAabbsDataKHR);                                          \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,                  \
+              VkAccelerationStructureGeometryInstancesDataKHR);                                      \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,                                 \
+              VkAccelerationStructureGeometryKHR);                                                   \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,                  \
+              VkAccelerationStructureGeometryTrianglesDataKHR);                                      \
+  COPY_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR,                             \
+              VkAccelerationStructureVersionInfoKHR);                                                \
   COPY_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,        \
               VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT);                              \
   COPY_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,                   \
@@ -761,22 +796,13 @@ static void AppendModifiedChainedStruct(byte *&tempMem, VkStruct *outputStruct,
   case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:                                      \
   /* Output structure containing objects. Must be *wrapped* not unwrapped. */               \
   /* So we treat this as unhandled in generic code and require specific handling. */        \
-  case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR:                    \
-  case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR:                       \
   case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT:           \
-  case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR:                            \
   case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV:                             \
-  case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR:                    \
-  case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR:                    \
-  case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR:                \
-  case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR:                               \
   case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:          \
-  case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR:                \
   case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV:                                    \
   case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:                \
   case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:                             \
   case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:             \
-  case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR:                           \
   case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC:                                   \
   case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID:               \
   case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:                                  \
@@ -794,10 +820,7 @@ static void AppendModifiedChainedStruct(byte *&tempMem, VkStruct *outputStruct,
   case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:        \
   case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:               \
   case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV:                                  \
-  case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR:                              \
-  case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR:                    \
   case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:                                  \
-  case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR:                    \
   case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT:                                  \
   case VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT:                                            \
   case VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT:                                  \
@@ -885,8 +908,6 @@ static void AppendModifiedChainedStruct(byte *&tempMem, VkStruct *outputStruct,
   case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL:                                     \
   case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL:                                   \
   case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL:                              \
-  case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:               \
-  case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:             \
   case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:               \
   case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:                      \
   case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:             \
@@ -953,8 +974,6 @@ static void AppendModifiedChainedStruct(byte *&tempMem, VkStruct *outputStruct,
   case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:      \
   case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:            \
   case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:               \
-  case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:                 \
-  case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:               \
   case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:           \
   case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:                         \
   case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:          \
@@ -1049,7 +1068,6 @@ static void AppendModifiedChainedStruct(byte *&tempMem, VkStruct *outputStruct,
   case VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR:                             \
   case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR:                          \
   case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR:                          \
-  case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:                   \
   case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
 
 size_t GetNextPatchSize(const void *pNext)
@@ -1086,8 +1104,7 @@ size_t GetNextPatchSize(const void *pNext)
       PROCESS_SIMPLE_STRUCTS();
 
       // complex structs to handle - require multiple allocations
-      case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: {
         memSize += sizeof(VkBindSparseInfo);
 
         VkBindSparseInfo *info = (VkBindSparseInfo *)next;
@@ -1104,8 +1121,7 @@ size_t GetNextPatchSize(const void *pNext)
           memSize += info->pImageBinds[i].bindCount * sizeof(VkSparseImageMemoryBind);
         break;
       }
-      case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2: {
         memSize += sizeof(VkBlitImageInfo2);
         VkBlitImageInfo2 *info = (VkBlitImageInfo2 *)next;
         memSize += info->regionCount * sizeof(VkImageBlit2);
@@ -1113,8 +1129,7 @@ size_t GetNextPatchSize(const void *pNext)
           memSize += GetNextPatchSize(info->pRegions[i].pNext);
         break;
       }
-      case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
-      {
+      case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: {
         memSize += sizeof(VkCommandBufferInheritanceRenderingInfo);
 
         VkCommandBufferInheritanceRenderingInfo *info =
@@ -1122,13 +1137,11 @@ size_t GetNextPatchSize(const void *pNext)
         memSize += info->colorAttachmentCount * sizeof(VkCommandBufferInheritanceRenderingInfo);
         break;
       }
-      case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: {
         memSize += sizeof(VkComputePipelineCreateInfo);
         break;
       }
-      case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2: {
         memSize += sizeof(VkCopyBufferInfo2);
         VkCopyBufferInfo2 *info = (VkCopyBufferInfo2 *)next;
         memSize += info->regionCount * sizeof(VkBufferCopy2);
@@ -1136,8 +1149,7 @@ size_t GetNextPatchSize(const void *pNext)
           memSize += GetNextPatchSize(info->pRegions[i].pNext);
         break;
       }
-      case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2: {
         memSize += sizeof(VkCopyBufferToImageInfo2);
         VkCopyBufferToImageInfo2 *info = (VkCopyBufferToImageInfo2 *)next;
         memSize += info->regionCount * sizeof(VkBufferImageCopy2);
@@ -1145,8 +1157,7 @@ size_t GetNextPatchSize(const void *pNext)
           memSize += GetNextPatchSize(info->pRegions[i].pNext);
         break;
       }
-      case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2: {
         memSize += sizeof(VkCopyImageToBufferInfo2);
         VkCopyImageToBufferInfo2 *info = (VkCopyImageToBufferInfo2 *)next;
         memSize += info->regionCount * sizeof(VkBufferImageCopy2);
@@ -1154,8 +1165,7 @@ size_t GetNextPatchSize(const void *pNext)
           memSize += GetNextPatchSize(info->pRegions[i].pNext);
         break;
       }
-      case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2: {
         memSize += sizeof(VkCopyImageInfo2);
         VkCopyImageInfo2 *info = (VkCopyImageInfo2 *)next;
         memSize += info->regionCount * sizeof(VkImageCopy2);
@@ -1163,8 +1173,7 @@ size_t GetNextPatchSize(const void *pNext)
           memSize += GetNextPatchSize(info->pRegions[i].pNext);
         break;
       }
-      case VK_STRUCTURE_TYPE_DEPENDENCY_INFO:
-      {
+      case VK_STRUCTURE_TYPE_DEPENDENCY_INFO: {
         memSize += sizeof(VkDependencyInfo);
 
         VkDependencyInfo *info = (VkDependencyInfo *)next;
@@ -1183,16 +1192,14 @@ size_t GetNextPatchSize(const void *pNext)
 
         break;
       }
-      case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: {
         memSize += sizeof(VkDescriptorSetAllocateInfo);
 
         VkDescriptorSetAllocateInfo *info = (VkDescriptorSetAllocateInfo *)next;
         memSize += info->descriptorSetCount * sizeof(VkDescriptorSetLayout);
         break;
       }
-      case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: {
         memSize += sizeof(VkDescriptorSetLayoutCreateInfo);
 
         VkDescriptorSetLayoutCreateInfo *info = (VkDescriptorSetLayoutCreateInfo *)next;
@@ -1203,32 +1210,28 @@ size_t GetNextPatchSize(const void *pNext)
             memSize += info->pBindings[i].descriptorCount * sizeof(VkSampler);
         break;
       }
-      case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS:
-      {
+      case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS: {
         memSize += sizeof(VkDeviceBufferMemoryRequirements);
 
         VkDeviceBufferMemoryRequirements *info = (VkDeviceBufferMemoryRequirements *)next;
         memSize += GetNextPatchSize(info->pCreateInfo);
         break;
       }
-      case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {
         memSize += sizeof(VkDeviceGroupDeviceCreateInfo);
 
         VkDeviceGroupDeviceCreateInfo *info = (VkDeviceGroupDeviceCreateInfo *)next;
         memSize += info->physicalDeviceCount * sizeof(VkPhysicalDevice);
         break;
       }
-      case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS:
-      {
+      case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS: {
         memSize += sizeof(VkDeviceImageMemoryRequirements);
 
         VkDeviceImageMemoryRequirements *info = (VkDeviceImageMemoryRequirements *)next;
         memSize += GetNextPatchSize(info->pCreateInfo);
         break;
       }
-      case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: {
         memSize += sizeof(VkFramebufferCreateInfo);
 
         VkFramebufferCreateInfo *info = (VkFramebufferCreateInfo *)next;
@@ -1238,8 +1241,7 @@ size_t GetNextPatchSize(const void *pNext)
       // this struct doesn't really need to be unwrapped but we allocate space for it since it
       // contains arrays that we will very commonly need to patch, to adjust image info/formats.
       // this saves us needing to iterate it outside and allocate extra space
-      case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {
         memSize += sizeof(VkFramebufferAttachmentsCreateInfo);
 
         VkFramebufferAttachmentsCreateInfo *info = (VkFramebufferAttachmentsCreateInfo *)next;
@@ -1250,8 +1252,7 @@ size_t GetNextPatchSize(const void *pNext)
 
         break;
       }
-      case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: {
         memSize += sizeof(VkFramebufferAttachmentImageInfo);
 
         // we add space for an extra VkFormat so we can push one onto the list
@@ -1261,8 +1262,7 @@ size_t GetNextPatchSize(const void *pNext)
 
         break;
       }
-      case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: {
         memSize += sizeof(VkGraphicsPipelineCreateInfo);
 
         VkGraphicsPipelineCreateInfo *info = (VkGraphicsPipelineCreateInfo *)next;
@@ -1318,32 +1318,28 @@ size_t GetNextPatchSize(const void *pNext)
         }
         break;
       }
-      case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: {
         memSize += sizeof(VkPipelineLayoutCreateInfo);
 
         VkPipelineLayoutCreateInfo *info = (VkPipelineLayoutCreateInfo *)next;
         memSize += info->setLayoutCount * sizeof(VkDescriptorSetLayout);
         break;
       }
-      case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
-      {
+      case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: {
         memSize += sizeof(VkPipelineLibraryCreateInfoKHR);
 
         VkPipelineLibraryCreateInfoKHR *info = (VkPipelineLibraryCreateInfoKHR *)next;
         memSize += info->libraryCount * sizeof(VkPipelineLibraryCreateInfoKHR);
         break;
       }
-      case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {
         memSize += sizeof(VkPipelineRenderingCreateInfo);
 
         VkPipelineRenderingCreateInfo *info = (VkPipelineRenderingCreateInfo *)next;
         memSize += info->colorAttachmentCount * sizeof(VkPipelineRenderingCreateInfo);
         break;
       }
-      case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
-      {
+      case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: {
         memSize += sizeof(VkPresentInfoKHR);
 
         VkPresentInfoKHR *info = (VkPresentInfoKHR *)next;
@@ -1351,8 +1347,7 @@ size_t GetNextPatchSize(const void *pNext)
         memSize += info->swapchainCount * sizeof(VkSwapchainKHR);
         break;
       }
-      case VK_STRUCTURE_TYPE_RENDERING_INFO:
-      {
+      case VK_STRUCTURE_TYPE_RENDERING_INFO: {
         memSize += sizeof(VkRenderingInfo);
 
         VkRenderingInfo *info = (VkRenderingInfo *)next;
@@ -1371,16 +1366,14 @@ size_t GetNextPatchSize(const void *pNext)
         }
         break;
       }
-      case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
-      {
+      case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {
         memSize += sizeof(VkRenderPassAttachmentBeginInfo);
 
         VkRenderPassAttachmentBeginInfo *info = (VkRenderPassAttachmentBeginInfo *)next;
         memSize += info->attachmentCount * sizeof(VkImageView);
         break;
       }
-      case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2: {
         memSize += sizeof(VkResolveImageInfo2);
         VkResolveImageInfo2 *info = (VkResolveImageInfo2 *)next;
         memSize += info->regionCount * sizeof(VkImageResolve2);
@@ -1388,16 +1381,14 @@ size_t GetNextPatchSize(const void *pNext)
           memSize += GetNextPatchSize(info->pRegions[i].pNext);
         break;
       }
-      case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO:
-      {
+      case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: {
         memSize += sizeof(VkSemaphoreWaitInfo);
 
         VkSemaphoreWaitInfo *info = (VkSemaphoreWaitInfo *)next;
         memSize += info->semaphoreCount * sizeof(VkSemaphore);
         break;
       }
-      case VK_STRUCTURE_TYPE_SUBMIT_INFO:
-      {
+      case VK_STRUCTURE_TYPE_SUBMIT_INFO: {
         memSize += sizeof(VkSubmitInfo);
 
         VkSubmitInfo *info = (VkSubmitInfo *)next;
@@ -1406,8 +1397,7 @@ size_t GetNextPatchSize(const void *pNext)
         memSize += info->signalSemaphoreCount * sizeof(VkSemaphore);
         break;
       }
-      case VK_STRUCTURE_TYPE_SUBMIT_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_SUBMIT_INFO_2: {
         memSize += sizeof(VkSubmitInfo2);
 
         VkSubmitInfo2 *info = (VkSubmitInfo2 *)next;
@@ -1425,16 +1415,14 @@ size_t GetNextPatchSize(const void *pNext)
           memSize += GetNextPatchSize(info->pSignalSemaphoreInfos[i].pNext);
         break;
       }
-      case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT:
-      {
+      case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: {
         memSize += sizeof(VkSwapchainPresentFenceInfoEXT);
 
         VkSwapchainPresentFenceInfoEXT *info = (VkSwapchainPresentFenceInfoEXT *)next;
         memSize += info->swapchainCount * sizeof(VkFence);
         break;
       }
-      case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
-      {
+      case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: {
         memSize += sizeof(VkWriteDescriptorSet);
 
         VkWriteDescriptorSet *info = (VkWriteDescriptorSet *)next;
@@ -1484,8 +1472,7 @@ size_t GetNextPatchSize(const void *pNext)
       case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
       case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
       case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
-      case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
-      {
+      case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: {
         RDCERR("Support for android external memory buffer extension not compiled in");
         break;
       }
@@ -1494,8 +1481,7 @@ size_t GetNextPatchSize(const void *pNext)
 #if ENABLED(RDOC_GGP)
         COPY_STRUCT_CAPTURE_ONLY(VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP, VkPresentFrameTokenGGP);
 #else
-      case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
-      {
+      case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: {
         RDCERR("Support for GGP frame token extension not compiled in");
         break;
       }
@@ -1542,8 +1528,7 @@ size_t GetNextPatchSize(const void *pNext)
         memSize += sizeof(VkFenceGetWin32HandleInfoKHR);
         break;
       case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
-      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-      {
+      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: {
         // the KHR and NV structs are identical
         memSize += sizeof(VkWin32KeyedMutexAcquireReleaseInfoKHR);
 
@@ -1570,8 +1555,7 @@ size_t GetNextPatchSize(const void *pNext)
       case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR:
       case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR:
       case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
-      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-      {
+      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: {
         RDCERR("Support for win32 external memory extensions not compiled in");
         break;
       }
@@ -1581,8 +1565,7 @@ size_t GetNextPatchSize(const void *pNext)
       case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
       case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
       case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
-      case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
-      {
+      case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: {
         // could be implemented but would need extra work or doesn't make sense right now
         RDCERR("Struct %s not handled in pNext chain", ToStr(next->sType).c_str());
         break;
@@ -1624,8 +1607,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
 #undef COPY_STRUCT_CAPTURE_ONLY
 #define COPY_STRUCT_CAPTURE_ONLY(StructType, StructName)                            \
-  case StructType:                                                                  \
-  {                                                                                 \
+  case StructType: {                                                                \
     if(IsCaptureMode(state))                                                        \
       CopyNextChainedStruct(sizeof(StructName), tempMem, nextInput, nextChainTail); \
     break;                                                                          \
@@ -1633,8 +1615,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
 #undef COPY_STRUCT
 #define COPY_STRUCT(StructType, StructName)                                       \
-  case StructType:                                                                \
-  {                                                                               \
+  case StructType: {                                                              \
     CopyNextChainedStruct(sizeof(StructName), tempMem, nextInput, nextChainTail); \
     break;                                                                        \
   }
@@ -1655,16 +1636,14 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
 #undef UNWRAP_STRUCT
 #define UNWRAP_STRUCT(StructType, StructName, ...)           \
-  case StructType:                                           \
-  {                                                          \
+  case StructType: {                                         \
     UNWRAP_STRUCT_INNER(StructType, StructName, __VA_ARGS__) \
     break;                                                   \
   }
 
 #undef UNWRAP_STRUCT_CAPTURE_ONLY
 #define UNWRAP_STRUCT_CAPTURE_ONLY(StructType, StructName, ...) \
-  case StructType:                                              \
-  {                                                             \
+  case StructType: {                                            \
     if(IsCaptureMode(state))                                    \
     {                                                           \
       UNWRAP_STRUCT_INNER(StructType, StructName, __VA_ARGS__)  \
@@ -1683,8 +1662,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
       PROCESS_SIMPLE_STRUCTS();
 
       // complex structs to handle - require multiple allocations
-      case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO: {
         const VkBindSparseInfo *in = (const VkBindSparseInfo *)nextInput;
         VkBindSparseInfo *out = (VkBindSparseInfo *)tempMem;
 
@@ -1774,8 +1752,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2: {
         const VkBlitImageInfo2 *in = (const VkBlitImageInfo2 *)nextInput;
         VkBlitImageInfo2 *out = (VkBlitImageInfo2 *)tempMem;
 
@@ -1799,8 +1776,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
-      {
+      case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO: {
         const VkCommandBufferInheritanceRenderingInfo *in =
             (const VkCommandBufferInheritanceRenderingInfo *)nextInput;
         VkCommandBufferInheritanceRenderingInfo *out =
@@ -1821,8 +1797,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO: {
         const VkComputePipelineCreateInfo *in = (const VkComputePipelineCreateInfo *)nextInput;
         VkComputePipelineCreateInfo *out = (VkComputePipelineCreateInfo *)tempMem;
 
@@ -1836,8 +1811,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2: {
         const VkCopyBufferInfo2 *in = (const VkCopyBufferInfo2 *)nextInput;
         VkCopyBufferInfo2 *out = (VkCopyBufferInfo2 *)tempMem;
 
@@ -1861,8 +1835,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2: {
         const VkCopyBufferToImageInfo2 *in = (const VkCopyBufferToImageInfo2 *)nextInput;
         VkCopyBufferToImageInfo2 *out = (VkCopyBufferToImageInfo2 *)tempMem;
 
@@ -1886,8 +1859,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2: {
         const VkCopyImageToBufferInfo2 *in = (const VkCopyImageToBufferInfo2 *)nextInput;
         VkCopyImageToBufferInfo2 *out = (VkCopyImageToBufferInfo2 *)tempMem;
 
@@ -1911,8 +1883,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2: {
         const VkCopyImageInfo2 *in = (const VkCopyImageInfo2 *)nextInput;
         VkCopyImageInfo2 *out = (VkCopyImageInfo2 *)tempMem;
 
@@ -1936,8 +1907,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_DEPENDENCY_INFO:
-      {
+      case VK_STRUCTURE_TYPE_DEPENDENCY_INFO: {
         const VkDependencyInfo *in = (const VkDependencyInfo *)nextInput;
         VkDependencyInfo *out = (VkDependencyInfo *)tempMem;
 
@@ -1982,8 +1952,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO: {
         const VkDescriptorSetAllocateInfo *in = (const VkDescriptorSetAllocateInfo *)nextInput;
         VkDescriptorSetAllocateInfo *out = (VkDescriptorSetAllocateInfo *)tempMem;
 
@@ -2003,8 +1972,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO: {
         const VkDescriptorSetLayoutCreateInfo *in =
             (const VkDescriptorSetLayoutCreateInfo *)nextInput;
         VkDescriptorSetLayoutCreateInfo *out = (VkDescriptorSetLayoutCreateInfo *)tempMem;
@@ -2038,8 +2006,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS:
-      {
+      case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS: {
         const VkDeviceBufferMemoryRequirements *in =
             (const VkDeviceBufferMemoryRequirements *)nextInput;
         VkDeviceBufferMemoryRequirements *out = (VkDeviceBufferMemoryRequirements *)tempMem;
@@ -2055,8 +2022,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO: {
         const VkDeviceGroupDeviceCreateInfo *in = (const VkDeviceGroupDeviceCreateInfo *)nextInput;
         VkDeviceGroupDeviceCreateInfo *out = (VkDeviceGroupDeviceCreateInfo *)tempMem;
 
@@ -2075,8 +2041,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS:
-      {
+      case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS: {
         const VkDeviceImageMemoryRequirements *in =
             (const VkDeviceImageMemoryRequirements *)nextInput;
         VkDeviceImageMemoryRequirements *out = (VkDeviceImageMemoryRequirements *)tempMem;
@@ -2093,8 +2058,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO: {
         const VkFramebufferCreateInfo *in = (const VkFramebufferCreateInfo *)nextInput;
         VkFramebufferCreateInfo *out = (VkFramebufferCreateInfo *)tempMem;
 
@@ -2120,8 +2084,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
       // this struct doesn't really need to be unwrapped but we allocate space for it since it
       // contains arrays that we will very commonly need to patch, to adjust image info/formats.
       // this saves us needing to iterate it outside and allocate extra space
-      case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO: {
         const VkFramebufferAttachmentsCreateInfo *in =
             (const VkFramebufferAttachmentsCreateInfo *)nextInput;
         VkFramebufferAttachmentsCreateInfo *out = (VkFramebufferAttachmentsCreateInfo *)tempMem;
@@ -2144,8 +2107,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO: {
         const VkFramebufferAttachmentImageInfo *in =
             (const VkFramebufferAttachmentImageInfo *)nextInput;
         VkFramebufferAttachmentImageInfo *out = (VkFramebufferAttachmentImageInfo *)tempMem;
@@ -2167,8 +2129,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO: {
         const VkGraphicsPipelineCreateInfo *in = (const VkGraphicsPipelineCreateInfo *)nextInput;
         VkGraphicsPipelineCreateInfo *out = (VkGraphicsPipelineCreateInfo *)tempMem;
 
@@ -2230,8 +2191,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO: {
         const VkPipelineLayoutCreateInfo *in = (const VkPipelineLayoutCreateInfo *)nextInput;
         VkPipelineLayoutCreateInfo *out = (VkPipelineLayoutCreateInfo *)tempMem;
 
@@ -2250,8 +2210,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
-      {
+      case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR: {
         const VkPipelineLibraryCreateInfoKHR *in = (const VkPipelineLibraryCreateInfoKHR *)nextInput;
         VkPipelineLibraryCreateInfoKHR *out = (VkPipelineLibraryCreateInfoKHR *)tempMem;
 
@@ -2270,8 +2229,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
-      {
+      case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO: {
         const VkPipelineRenderingCreateInfo *in = (const VkPipelineRenderingCreateInfo *)nextInput;
         VkPipelineRenderingCreateInfo *out = (VkPipelineRenderingCreateInfo *)tempMem;
 
@@ -2290,8 +2248,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
-      {
+      case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR: {
         const VkPresentInfoKHR *in = (const VkPresentInfoKHR *)nextInput;
         VkPresentInfoKHR *out = (VkPresentInfoKHR *)tempMem;
 
@@ -2315,8 +2272,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_RENDERING_INFO:
-      {
+      case VK_STRUCTURE_TYPE_RENDERING_INFO: {
         const VkRenderingInfo *in = (const VkRenderingInfo *)nextInput;
         VkRenderingInfo *out = (VkRenderingInfo *)tempMem;
 
@@ -2378,8 +2334,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
-      {
+      case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO: {
         const VkRenderPassAttachmentBeginInfo *in =
             (const VkRenderPassAttachmentBeginInfo *)nextInput;
         VkRenderPassAttachmentBeginInfo *out = (VkRenderPassAttachmentBeginInfo *)tempMem;
@@ -2399,8 +2354,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2: {
         const VkResolveImageInfo2 *in = (const VkResolveImageInfo2 *)nextInput;
         VkResolveImageInfo2 *out = (VkResolveImageInfo2 *)tempMem;
 
@@ -2424,8 +2378,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO:
-      {
+      case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO: {
         const VkSemaphoreWaitInfo *in = (const VkSemaphoreWaitInfo *)nextInput;
         VkSemaphoreWaitInfo *out = (VkSemaphoreWaitInfo *)tempMem;
 
@@ -2444,8 +2397,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_SUBMIT_INFO:
-      {
+      case VK_STRUCTURE_TYPE_SUBMIT_INFO: {
         const VkSubmitInfo *in = (const VkSubmitInfo *)nextInput;
         VkSubmitInfo *out = (VkSubmitInfo *)tempMem;
 
@@ -2474,8 +2426,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_SUBMIT_INFO_2:
-      {
+      case VK_STRUCTURE_TYPE_SUBMIT_INFO_2: {
         const VkSubmitInfo2 *in = (const VkSubmitInfo2 *)nextInput;
         VkSubmitInfo2 *out = (VkSubmitInfo2 *)tempMem;
 
@@ -2519,8 +2470,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT:
-      {
+      case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT: {
         const VkSwapchainPresentFenceInfoEXT *in = (const VkSwapchainPresentFenceInfoEXT *)nextInput;
         VkSwapchainPresentFenceInfoEXT *out = (VkSwapchainPresentFenceInfoEXT *)tempMem;
 
@@ -2539,8 +2489,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
         break;
       }
-      case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
-      {
+      case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET: {
         const VkWriteDescriptorSet *in = (const VkWriteDescriptorSet *)nextInput;
         VkWriteDescriptorSet *out = (VkWriteDescriptorSet *)tempMem;
 
@@ -2556,8 +2505,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
           case VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER:
           case VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE:
           case VK_DESCRIPTOR_TYPE_STORAGE_IMAGE:
-          case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT:
-          {
+          case VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT: {
             VkDescriptorImageInfo *outBindings = (VkDescriptorImageInfo *)tempMem;
             tempMem += sizeof(VkDescriptorImageInfo) * in->descriptorCount;
 
@@ -2571,8 +2519,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
             break;
           }
           case VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER:
-          case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER:
-          {
+          case VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER: {
             VkBufferView *outBindings = (VkBufferView *)tempMem;
             tempMem += sizeof(VkBufferView) * in->descriptorCount;
 
@@ -2584,8 +2531,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
           case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER:
           case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER:
           case VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC:
-          case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC:
-          {
+          case VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC: {
             VkDescriptorBufferInfo *outBindings = (VkDescriptorBufferInfo *)tempMem;
             tempMem += sizeof(VkDescriptorBufferInfo) * in->descriptorCount;
 
@@ -2597,8 +2543,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 
             break;
           }
-          case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK:
-          {
+          case VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK: {
             // nothing to do/patch
             break;
           }
@@ -2628,8 +2573,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
       case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
       case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
       case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
-      case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
-      {
+      case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: {
         RDCERR("Support for android external memory buffer extension not compiled in");
         break;
       }
@@ -2638,8 +2582,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
 #if ENABLED(RDOC_GGP)
         COPY_STRUCT_CAPTURE_ONLY(VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP, VkPresentFrameTokenGGP);
 #else
-      case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
-      {
+      case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: {
         RDCERR("Support for GGP frame token extension not compiled in");
         break;
       }
@@ -2684,8 +2627,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
                                    VkFenceGetWin32HandleInfoKHR, UnwrapInPlace(out->fence));
 
       case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
-      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-      {
+      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: {
         // strip during replay
         if(IsCaptureMode(state))
         {
@@ -2736,8 +2678,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
       case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR:
       case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR:
       case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
-      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-      {
+      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: {
         RDCERR("Support for win32 external memory extensions not compiled in");
         nextChainTail->pNext = nextInput;
         break;
@@ -2748,8 +2689,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
       case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
       case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
       case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
-      case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
-      {
+      case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: {
         // could be implemented but would need extra work or doesn't make sense right now
         RDCERR("Struct %s not handled in %s pNext chain", ToStr(nextInput->sType).c_str(),
                structName);
@@ -2765,8 +2705,7 @@ void UnwrapNextChain(CaptureState state, const char *structName, byte *&tempMem,
           break;
         }
 
-      case VK_STRUCTURE_TYPE_MAX_ENUM:
-      {
+      case VK_STRUCTURE_TYPE_MAX_ENUM: {
         RDCERR("Invalid value %x in %s pNext chain", nextInput->sType, structName);
         nextChainTail->pNext = nextInput;
         break;
@@ -2782,8 +2721,8 @@ void CopyNextChainForPatching(const char *structName, byte *&tempMem, VkBaseInSt
   VkBaseInStructure *nextChainTail = infoStruct;
   const VkBaseInStructure *nextInput = (const VkBaseInStructure *)infoStruct->pNext;
 
-// simplified version of UnwrapNextChain which just copies everything. Useful for when we need to
-// shallow duplicate a next chain (e.g. because we'll copy and patch one struct)
+  // simplified version of UnwrapNextChain which just copies everything. Useful for when we need to
+  // shallow duplicate a next chain (e.g. because we'll copy and patch one struct)
 
 #undef COPY_STRUCT_CAPTURE_ONLY
 #define COPY_STRUCT_CAPTURE_ONLY(StructType, StructName)                          \
@@ -2946,8 +2885,7 @@ void CopyNextChainForPatching(const char *structName, byte *&tempMem, VkBaseInSt
       case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
       case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
       case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
-      case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
-      {
+      case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID: {
         RDCERR("Support for android external memory buffer extension not compiled in");
         break;
       }
@@ -2956,8 +2894,7 @@ void CopyNextChainForPatching(const char *structName, byte *&tempMem, VkBaseInSt
 #if ENABLED(RDOC_GGP)
         COPY_STRUCT_CAPTURE_ONLY(VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP, VkPresentFrameTokenGGP);
 #else
-      case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
-      {
+      case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP: {
         RDCERR("Support for GGP frame token extension not compiled in");
         break;
       }
@@ -3024,8 +2961,7 @@ void CopyNextChainForPatching(const char *structName, byte *&tempMem, VkBaseInSt
       case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR:
       case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR:
       case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
-      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
-      {
+      case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR: {
         RDCERR("Support for win32 external memory extensions not compiled in");
         nextChainTail->pNext = nextInput;
         break;
@@ -3036,8 +2972,7 @@ void CopyNextChainForPatching(const char *structName, byte *&tempMem, VkBaseInSt
       case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
       case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
       case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
-      case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
-      {
+      case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT: {
         // could be implemented but would need extra work or doesn't make sense right now
         RDCERR("Struct %s not handled in %s pNext chain", ToStr(nextInput->sType).c_str(),
                structName);
@@ -3053,8 +2988,7 @@ void CopyNextChainForPatching(const char *structName, byte *&tempMem, VkBaseInSt
           break;
         }
 
-      case VK_STRUCTURE_TYPE_MAX_ENUM:
-      {
+      case VK_STRUCTURE_TYPE_MAX_ENUM: {
         RDCERR("Invalid value %x in %s pNext chain", nextInput->sType, structName);
         nextChainTail->pNext = nextInput;
         break;
diff --git a/renderdoc/driver/vulkan/vk_resources.cpp b/renderdoc/driver/vulkan/vk_resources.cpp
index 487212462..ebd2b2c80 100644
--- a/renderdoc/driver/vulkan/vk_resources.cpp
+++ b/renderdoc/driver/vulkan/vk_resources.cpp
@@ -55,6 +55,8 @@ WRAPPED_POOL_INST(WrappedVkSwapchainKHR)
 WRAPPED_POOL_INST(WrappedVkSurfaceKHR)
 WRAPPED_POOL_INST(WrappedVkDescriptorUpdateTemplate)
 WRAPPED_POOL_INST(WrappedVkSamplerYcbcrConversion)
+WRAPPED_POOL_INST(WrappedVkAccelerationStructureKHR)
+WRAPPED_POOL_INST(WrappedVkDeferredOperationKHR)
 
 byte VkResourceRecord::markerValue[32] = {
     0xaa, 0xbb, 0xcc, 0xdd, 0x88, 0x77, 0x66, 0x55, 0x01, 0x23, 0x45, 0x67, 0x98, 0x76, 0x54, 0x32,
@@ -141,6 +143,10 @@ VkResourceType IdentifyTypeByPtr(WrappedVkRes *ptr)
     return eResDescUpdateTemplate;
   if(WrappedVkSamplerYcbcrConversion::IsAlloc(ptr))
     return eResSamplerConversion;
+  if(WrappedVkAccelerationStructureKHR::IsAlloc(ptr))
+    return eResAccelerationStructure;  
+  if(WrappedVkDeferredOperationKHR::IsAlloc(ptr))
+    return eResDeferredOperation;
 
   RDCERR("Unknown type for ptr 0x%p", ptr);
 
diff --git a/renderdoc/driver/vulkan/vk_resources.h b/renderdoc/driver/vulkan/vk_resources.h
index ddd78127a..10a7ad0c6 100644
--- a/renderdoc/driver/vulkan/vk_resources.h
+++ b/renderdoc/driver/vulkan/vk_resources.h
@@ -75,6 +75,8 @@ enum VkResourceType
   eResSurface,
   eResDescUpdateTemplate,
   eResSamplerConversion,
+  eResAccelerationStructure,
+  eResDeferredOperation,
 };
 
 DECLARE_REFLECTION_ENUM(VkResourceType);
@@ -558,7 +560,33 @@ struct WrappedVkSamplerYcbcrConversion : WrappedVkNonDispRes
   {
     TypeEnum = eResSamplerConversion,
   };
-};
+  };
+struct WrappedVkAccelerationStructureKHR : WrappedVkNonDispRes
+{
+  WrappedVkAccelerationStructureKHR(VkAccelerationStructureKHR obj, ResourceId objId)
+      : WrappedVkNonDispRes(obj, objId)
+  {
+  }
+  typedef VkAccelerationStructureKHR InnerType;
+  ALLOCATE_WITH_WRAPPED_POOL(WrappedVkAccelerationStructureKHR);
+  enum
+  {
+    TypeEnum = eResAccelerationStructure,
+  };
+  };
+struct WrappedVkDeferredOperationKHR : WrappedVkNonDispRes
+{
+  WrappedVkDeferredOperationKHR(VkDeferredOperationKHR obj, ResourceId objId)
+      : WrappedVkNonDispRes(obj, objId)
+  {
+  }
+  typedef VkDeferredOperationKHR InnerType;
+  ALLOCATE_WITH_WRAPPED_POOL(WrappedVkDeferredOperationKHR);
+  enum
+  {
+    TypeEnum = eResDeferredOperation,
+  };
+  };
 
 // VkDisplayKHR and VkDisplayModeKHR are both UNWRAPPED because there's no need to wrap them.
 // The only thing we need to wrap VkSurfaceKHR for is to get back the window from it later.
@@ -658,6 +686,8 @@ UNWRAP_NONDISP_HELPER(VkSwapchainKHR)
 UNWRAP_NONDISP_HELPER(VkSurfaceKHR)
 UNWRAP_NONDISP_HELPER(VkDescriptorUpdateTemplate)
 UNWRAP_NONDISP_HELPER(VkSamplerYcbcrConversion)
+UNWRAP_NONDISP_HELPER(VkAccelerationStructureKHR)
+UNWRAP_NONDISP_HELPER(VkDeferredOperationKHR)
 
 // VkDisplayKHR and VkDisplayModeKHR are both UNWRAPPED because there's no need to wrap them.
 // The only thing we need to wrap VkSurfaceKHR for is to get back the window from it later.
diff --git a/renderdoc/driver/vulkan/vk_serialise.cpp b/renderdoc/driver/vulkan/vk_serialise.cpp
index a15bcb133..a8b8e86dc 100644
--- a/renderdoc/driver/vulkan/vk_serialise.cpp
+++ b/renderdoc/driver/vulkan/vk_serialise.cpp
@@ -573,6 +573,38 @@ SERIALISE_VK_HANDLES();
   PNEXT_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT,         \
                VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT)                                \
                                                                                                        \
+ /* VK_KHR_acceleration_structure */                                                                  \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR,                      \
+               VkWriteDescriptorSetAccelerationStructureKHR)                                           \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR,                       \
+               VkAccelerationStructureBuildGeometryInfoKHR)                                            \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR,                  \
+               VkPhysicalDeviceAccelerationStructureFeaturesKHR)                                       \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR,                \
+               VkPhysicalDeviceAccelerationStructurePropertiesKHR)                                     \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR,                          \
+               VkAccelerationStructureBuildSizesInfoKHR)                                               \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR,                               \
+               VkAccelerationStructureCreateInfoKHR)                                                   \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR,                       \
+               VkAccelerationStructureDeviceAddressInfoKHR)                                            \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR,                       \
+               VkAccelerationStructureGeometryAabbsDataKHR)                                            \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR,                   \
+               VkAccelerationStructureGeometryInstancesDataKHR)                                        \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR,                                  \
+               VkAccelerationStructureGeometryKHR)                                                     \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR,                   \
+               VkAccelerationStructureGeometryTrianglesDataKHR)                                        \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR,                              \
+               VkAccelerationStructureVersionInfoKHR)                                                  \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR,                                 \
+               VkCopyAccelerationStructureInfoKHR)                                                     \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR,                       \
+               VkCopyAccelerationStructureToMemoryInfoKHR)                                             \
+  PNEXT_STRUCT(VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR,                       \
+               VkCopyMemoryToAccelerationStructureInfoKHR)                                             \
+                                                                                                                                    \
   /* VK_EXT_border_color_swizzle */                                                                    \
   PNEXT_STRUCT(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT,                    \
                VkPhysicalDeviceBorderColorSwizzleFeaturesEXT)                                          \
@@ -1602,23 +1634,6 @@ SERIALISE_VK_HANDLES();
   /* VK_INTEL_shader_integer_functions2 */                                                             \
   PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL)       \
                                                                                                        \
-  /* VK_KHR_acceleration_structure */                                                                  \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR)                  \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR)                     \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR)                          \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR)                  \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR)                  \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR)              \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR)                             \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR)              \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR)                         \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR)                            \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR)                  \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR)                  \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR)             \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR)           \
-  PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR)                 \
-                                                                                                       \
   /* VK_KHR_map_memory2 */                                                                             \
   PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR)                                             \
   PNEXT_UNSUPPORTED(VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR)                                           \
@@ -8323,6 +8338,289 @@ void Deserialise(const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT &
   DeserialiseNext(el.pNext);
 }
 
+//raytracing
+template <>
+void Deserialise(const VkAccelerationStructureGeometryTrianglesDataKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkAccelerationStructureGeometryTrianglesDataKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(vertexFormat);
+  SERIALISE_MEMBER(vertexData);
+  SERIALISE_MEMBER(vertexStride);
+  SERIALISE_MEMBER(maxVertex);
+  SERIALISE_MEMBER(indexType);
+  SERIALISE_MEMBER(indexData);
+  SERIALISE_MEMBER(transformData);
+}
+
+template <>
+void Deserialise(const VkAccelerationStructureGeometryAabbsDataKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkAccelerationStructureGeometryAabbsDataKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(stride);
+  SERIALISE_MEMBER(data);
+}
+
+template <>
+void Deserialise(const VkAccelerationStructureGeometryInstancesDataKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkAccelerationStructureGeometryInstancesDataKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(arrayOfPointers);
+  SERIALISE_MEMBER(data);
+}
+
+template <>
+void Deserialise(const VkAccelerationStructureGeometryKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkAccelerationStructureGeometryKHR &el)
+{
+  RDCASSERT(ser.IsReading() || el.sType == VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(geometryType);
+  SERIALISE_MEMBER(geometry);
+  SERIALISE_MEMBER_VKFLAGS(VkGeometryFlagsKHR, flags);
+}
+
+template <>
+void Deserialise(const VkAccelerationStructureBuildGeometryInfoKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkAccelerationStructureBuildGeometryInfoKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(type);
+  SERIALISE_MEMBER_VKFLAGS(VkBuildAccelerationStructureFlagsKHR, flags);
+  SERIALISE_MEMBER(mode);
+  SERIALISE_MEMBER(srcAccelerationStructure);
+  SERIALISE_MEMBER(dstAccelerationStructure);
+  SERIALISE_MEMBER(geometryCount);
+  SERIALISE_MEMBER_ARRAY(pGeometries, geometryCount);
+  SERIALISE_MEMBER_ARRAY(ppGeometries, geometryCount);
+  SERIALISE_MEMBER(scratchData);
+}
+
+
+template <>
+void Deserialise(const VkAccelerationStructureCreateInfoKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkAccelerationStructureCreateInfoKHR &el)
+{
+  RDCASSERT(ser.IsReading() || el.sType == VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER_VKFLAGS(VkAccelerationStructureCreateFlagsKHR, createFlags);
+  SERIALISE_MEMBER(buffer);
+  SERIALISE_MEMBER(offset);
+  SERIALISE_MEMBER(size);
+  SERIALISE_MEMBER(type);
+  SERIALISE_MEMBER(deviceAddress);
+}
+
+template <>
+void Deserialise(const VkWriteDescriptorSetAccelerationStructureKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkWriteDescriptorSetAccelerationStructureKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(accelerationStructureCount);
+  SERIALISE_MEMBER_ARRAY(pAccelerationStructures, accelerationStructureCount);
+}
+
+template <>
+void Deserialise(const VkPhysicalDeviceAccelerationStructureFeaturesKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkPhysicalDeviceAccelerationStructureFeaturesKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(accelerationStructure);
+  SERIALISE_MEMBER(accelerationStructureCaptureReplay);
+  SERIALISE_MEMBER(accelerationStructureIndirectBuild);
+  SERIALISE_MEMBER(accelerationStructureHostCommands);
+  SERIALISE_MEMBER(descriptorBindingAccelerationStructureUpdateAfterBind);
+}
+
+
+template <>
+void Deserialise(const VkPhysicalDeviceAccelerationStructurePropertiesKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkPhysicalDeviceAccelerationStructurePropertiesKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(maxGeometryCount);
+  SERIALISE_MEMBER(maxInstanceCount);
+  SERIALISE_MEMBER(maxPrimitiveCount);
+  SERIALISE_MEMBER(maxPerStageDescriptorAccelerationStructures);
+  SERIALISE_MEMBER(maxPerStageDescriptorUpdateAfterBindAccelerationStructures);
+  SERIALISE_MEMBER(maxDescriptorSetAccelerationStructures);
+  SERIALISE_MEMBER(maxDescriptorSetUpdateAfterBindAccelerationStructures);
+  SERIALISE_MEMBER(minAccelerationStructureScratchOffsetAlignment);
+}
+
+template <>
+void Deserialise(const VkAccelerationStructureDeviceAddressInfoKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkAccelerationStructureDeviceAddressInfoKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(accelerationStructure);
+}
+
+template <>
+void Deserialise(const VkAccelerationStructureVersionInfoKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkAccelerationStructureVersionInfoKHR &el)
+{
+  RDCASSERT(ser.IsReading() || el.sType == VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(pVersionData);
+}
+
+template <>
+void Deserialise(const VkCopyAccelerationStructureToMemoryInfoKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkCopyAccelerationStructureToMemoryInfoKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(src);
+  SERIALISE_MEMBER(dst);
+  SERIALISE_MEMBER(mode);
+}
+
+template <>
+void Deserialise(const VkCopyMemoryToAccelerationStructureInfoKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkCopyMemoryToAccelerationStructureInfoKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(src);
+  SERIALISE_MEMBER(dst);
+  SERIALISE_MEMBER(mode);
+}
+
+
+template <>
+void Deserialise(const VkCopyAccelerationStructureInfoKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkCopyAccelerationStructureInfoKHR &el)
+{
+  RDCASSERT(ser.IsReading() || el.sType == VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(src);
+  SERIALISE_MEMBER(dst);
+  SERIALISE_MEMBER(mode);
+}
+
+template <>
+void Deserialise(const VkAccelerationStructureBuildSizesInfoKHR &el)
+{
+  DeserialiseNext(el.pNext);
+}
+
+template <typename SerialiserType>
+void DoSerialise(SerialiserType &ser, VkAccelerationStructureBuildSizesInfoKHR &el)
+{
+  RDCASSERT(ser.IsReading() ||
+            el.sType == VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR);
+  SerialiseNext(ser, el.sType, el.pNext);
+
+  SERIALISE_MEMBER(accelerationStructureSize);
+  SERIALISE_MEMBER(updateScratchSize);
+  SERIALISE_MEMBER(buildScratchSize);
+}
+
 template <typename SerialiserType>
 void DoSerialise(SerialiserType &ser, VkPhysicalDeviceShaderImageFootprintFeaturesNV &el)
 {
@@ -11682,6 +11980,22 @@ INSTANTIATE_SERIALISE_TYPE(VkValidationFlagsEXT);
 INSTANTIATE_SERIALISE_TYPE(VkVertexInputAttributeDescription2EXT);
 INSTANTIATE_SERIALISE_TYPE(VkVertexInputBindingDescription2EXT);
 INSTANTIATE_SERIALISE_TYPE(VkWriteDescriptorSet);
+//raytracing
+INSTANTIATE_SERIALISE_TYPE(VkWriteDescriptorSetAccelerationStructureKHR);
+INSTANTIATE_SERIALISE_TYPE(VkAccelerationStructureBuildGeometryInfoKHR);
+INSTANTIATE_SERIALISE_TYPE(VkPhysicalDeviceAccelerationStructureFeaturesKHR);
+INSTANTIATE_SERIALISE_TYPE(VkPhysicalDeviceAccelerationStructurePropertiesKHR);
+INSTANTIATE_SERIALISE_TYPE(VkAccelerationStructureCreateInfoKHR);
+INSTANTIATE_SERIALISE_TYPE(VkAccelerationStructureDeviceAddressInfoKHR);
+INSTANTIATE_SERIALISE_TYPE(VkAccelerationStructureGeometryAabbsDataKHR);
+INSTANTIATE_SERIALISE_TYPE(VkAccelerationStructureGeometryInstancesDataKHR);
+INSTANTIATE_SERIALISE_TYPE(VkAccelerationStructureGeometryKHR);
+INSTANTIATE_SERIALISE_TYPE(VkAccelerationStructureGeometryTrianglesDataKHR);
+INSTANTIATE_SERIALISE_TYPE(VkAccelerationStructureVersionInfoKHR);
+INSTANTIATE_SERIALISE_TYPE(VkCopyAccelerationStructureInfoKHR);
+INSTANTIATE_SERIALISE_TYPE(VkCopyAccelerationStructureToMemoryInfoKHR);
+INSTANTIATE_SERIALISE_TYPE(VkCopyMemoryToAccelerationStructureInfoKHR);
+INSTANTIATE_SERIALISE_TYPE(VkAccelerationStructureBuildSizesInfoKHR);
 
 // plain structs with no next chain
 INSTANTIATE_SERIALISE_TYPE(VkAllocationCallbacks);
diff --git a/renderdoc/driver/vulkan/vk_stringise.cpp b/renderdoc/driver/vulkan/vk_stringise.cpp
index 8203f4598..9dd3526a0 100644
--- a/renderdoc/driver/vulkan/vk_stringise.cpp
+++ b/renderdoc/driver/vulkan/vk_stringise.cpp
@@ -28,7 +28,7 @@
 template <>
 rdcstr DoStringise(const VulkanChunk &el)
 {
-  RDCCOMPILE_ASSERT((uint32_t)VulkanChunk::Max == 1178, "Chunks changed without updating names");
+  RDCCOMPILE_ASSERT((uint32_t)VulkanChunk::Max == 1199, "Chunks changed without updating names");
 
   BEGIN_ENUM_STRINGISE(VulkanChunk)
   {
@@ -210,6 +210,27 @@ rdcstr DoStringise(const VulkanChunk &el)
     STRINGISE_ENUM_CLASS(vkCmdSetFragmentShadingRateKHR)
     STRINGISE_ENUM_CLASS(vkSetDeviceMemoryPriorityEXT)
     STRINGISE_ENUM_CLASS(vkCmdSetAttachmentFeedbackLoopEnableEXT)
+    STRINGISE_ENUM_CLASS(vkCreateAccelerationStructureKHR)
+    STRINGISE_ENUM_CLASS(vkDestroyAccelerationStructureKHR)
+    STRINGISE_ENUM_CLASS(vkCmdBuildAccelerationStructuresKHR)
+    STRINGISE_ENUM_CLASS(vkCmdBuildAccelerationStructuresIndirectKHR)
+    STRINGISE_ENUM_CLASS(vkBuildAccelerationStructuresKHR)
+    STRINGISE_ENUM_CLASS(vkCopyAccelerationStructureKHR)
+    STRINGISE_ENUM_CLASS(vkCopyAccelerationStructureToMemoryKHR)
+    STRINGISE_ENUM_CLASS(vkCopyMemoryToAccelerationStructureKHR)
+    STRINGISE_ENUM_CLASS(vkWriteAccelerationStructuresPropertiesKHR)
+    STRINGISE_ENUM_CLASS(vkCmdCopyAccelerationStructureKHR)
+    STRINGISE_ENUM_CLASS(vkCmdCopyAccelerationStructureToMemoryKHR)
+    STRINGISE_ENUM_CLASS(vkCmdCopyMemoryToAccelerationStructureKHR)
+    STRINGISE_ENUM_CLASS(vkGetAccelerationStructureDeviceAddressKHR)
+    STRINGISE_ENUM_CLASS(vkCmdWriteAccelerationStructuresPropertiesKHR)
+    STRINGISE_ENUM_CLASS(vkGetDeviceAccelerationStructureCompatibilityKHR)
+    STRINGISE_ENUM_CLASS(vkGetAccelerationStructureBuildSizesKHR)
+    STRINGISE_ENUM_CLASS(vkCreateDeferredOperationKHR)
+    STRINGISE_ENUM_CLASS(vkDestroyDeferredOperationKHR)
+    STRINGISE_ENUM_CLASS(vkGetDeferredOperationMaxConcurrencyKHR)
+    STRINGISE_ENUM_CLASS(vkGetDeferredOperationResultKHR)
+    STRINGISE_ENUM_CLASS(vkDeferredOperationJoinKHR)
     STRINGISE_ENUM_CLASS_NAMED(Max, "Max Chunk");
   }
   END_ENUM_STRINGISE()
@@ -3661,6 +3682,63 @@ rdcstr DoStringise(const VkPackedVersion &el)
                            VK_VERSION_MINOR(el.version), VK_VERSION_PATCH(el.version));
 }
 
+// raytracing
+template <>
+rdcstr DoStringise(const VkBuildAccelerationStructureModeKHR &el)
+{
+  BEGIN_ENUM_STRINGISE(VkBuildAccelerationStructureModeKHR);
+  {
+    STRINGISE_ENUM(VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR);
+    STRINGISE_ENUM(VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR);
+  }
+  END_ENUM_STRINGISE();
+}
+
+template <>
+rdcstr DoStringise(const VkAccelerationStructureCreateFlagBitsKHR &el)
+{
+  BEGIN_BITFIELD_STRINGISE(VkAccelerationStructureCreateFlagBitsKHR);
+  {
+    STRINGISE_BITFIELD_BIT(VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR);
+    STRINGISE_BITFIELD_BIT(VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT);
+    STRINGISE_BITFIELD_BIT(VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV);
+  }
+  END_BITFIELD_STRINGISE();
+}
+
+template <>
+rdcstr DoStringise(const VkBuildAccelerationStructureFlagBitsKHR &el)
+{
+  BEGIN_BITFIELD_STRINGISE(VkBuildAccelerationStructureFlagBitsKHR);
+  {
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR);
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR);
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR);
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR);
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR);
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV);
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_EXT);
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_EXT);
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_EXT);
+#ifdef VK_ENABLE_BETA_EXTENSIONS
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_NV);
+#endif
+    STRINGISE_BITFIELD_BIT(VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_KHR);
+  }
+  END_BITFIELD_STRINGISE();
+}
+
+template <>
+rdcstr DoStringise(const VkGeometryFlagBitsKHR &el)
+{
+  BEGIN_BITFIELD_STRINGISE(VkGeometryFlagBitsKHR);
+  {
+    STRINGISE_BITFIELD_BIT(VK_GEOMETRY_OPAQUE_BIT_KHR);
+    STRINGISE_BITFIELD_BIT(VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR);
+  }
+  END_BITFIELD_STRINGISE();
+}
+
 #ifdef VK_USE_PLATFORM_WIN32_KHR
 template <>
 rdcstr DoStringise(const VkFullScreenExclusiveEXT &el)
diff --git a/renderdoc/driver/vulkan/wrappers/vk_device_funcs.cpp b/renderdoc/driver/vulkan/wrappers/vk_device_funcs.cpp
index a9c9e6c8c..6fa82a83d 100644
--- a/renderdoc/driver/vulkan/wrappers/vk_device_funcs.cpp
+++ b/renderdoc/driver/vulkan/wrappers/vk_device_funcs.cpp
@@ -3104,6 +3104,24 @@ bool WrappedVulkan::Serialise_vkCreateDevice(SerialiserType &ser, VkPhysicalDevi
         m_DynAttachmentLoop = ext->attachmentFeedbackLoopDynamicState != VK_FALSE;
       }
       END_PHYS_EXT_CHECK();
+      //raytracing
+      BEGIN_PHYS_EXT_CHECK(VkPhysicalDeviceAccelerationStructureFeaturesKHR,
+                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR);
+      {
+        CHECK_PHYS_EXT_FEATURE(accelerationStructure);
+        CHECK_PHYS_EXT_FEATURE(accelerationStructureCaptureReplay);
+        CHECK_PHYS_EXT_FEATURE(accelerationStructureIndirectBuild);
+        CHECK_PHYS_EXT_FEATURE(accelerationStructureHostCommands);
+        CHECK_PHYS_EXT_FEATURE(descriptorBindingAccelerationStructureUpdateAfterBind);
+      }
+      END_PHYS_EXT_CHECK();
+
+  /*    BEGIN_PHYS_EXT_CHECK(VkPhysicalDeviceAccelerationStructurePropertiesKHR,
+                           VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR);
+      {
+        CHECK_PHYS_EXT_FEATURE();
+      }
+      END_PHYS_EXT_CHECK();*/
 
       BEGIN_PHYS_EXT_CHECK(VkPhysicalDeviceImage2DViewOf3DFeaturesEXT,
                            VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT);
diff --git a/renderdoc/driver/vulkan/wrappers/vk_misc_funcs.cpp b/renderdoc/driver/vulkan/wrappers/vk_misc_funcs.cpp
index a648a5372..0e517bc44 100644
--- a/renderdoc/driver/vulkan/wrappers/vk_misc_funcs.cpp
+++ b/renderdoc/driver/vulkan/wrappers/vk_misc_funcs.cpp
@@ -184,6 +184,8 @@ DESTROY_IMPL(VkCommandPool, DestroyCommandPool)
 DESTROY_IMPL(VkQueryPool, DestroyQueryPool)
 DESTROY_IMPL(VkDescriptorUpdateTemplate, DestroyDescriptorUpdateTemplate)
 DESTROY_IMPL(VkSamplerYcbcrConversion, DestroySamplerYcbcrConversion)
+DESTROY_IMPL(VkAccelerationStructureKHR, DestroyAccelerationStructureKHR)
+DESTROY_IMPL(VkDeferredOperationKHR, DestroyDeferredOperationKHR)
 
 #undef DESTROY_IMPL
 
@@ -568,6 +570,21 @@ bool WrappedVulkan::ReleaseResource(WrappedVkRes *res)
       vt->DestroySamplerYcbcrConversion(Unwrap(dev), real, NULL);
       break;
     }
+    //raytracing
+    case eResAccelerationStructure: 
+    {
+      VkAccelerationStructureKHR real = nondisp->real.As<VkAccelerationStructureKHR>();
+      GetResourceManager()->ReleaseWrappedResource(VkAccelerationStructureKHR(handle));
+      vt->DestroyAccelerationStructureKHR(Unwrap(dev), real, NULL);
+      break;
+    }
+    case eResDeferredOperation: 
+    {
+      VkDeferredOperationKHR real = nondisp->real.As<VkDeferredOperationKHR>();
+      GetResourceManager()->ReleaseWrappedResource(VkDeferredOperationKHR(handle));
+      vt->DestroyDeferredOperationKHR(Unwrap(dev), real, NULL);
+      break;
+    }    
   }
 
   return true;
@@ -1793,199 +1810,1164 @@ VkResult WrappedVulkan::vkCreateSamplerYcbcrConversion(
   return ret;
 }
 
-VkBool32 VKAPI_PTR UserDebugReportCallback(VkDebugReportFlagsEXT flags,
-                                           VkDebugReportObjectTypeEXT objectType, uint64_t object,
-                                           size_t location, int32_t messageCode,
-                                           const char *pLayerPrefix, const char *pMessage,
-                                           void *pUserData)
+//raytracing
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCreateAccelerationStructureKHR(
+    SerialiserType &ser, VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo,
+    const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure)
 {
-  UserDebugReportCallbackData *user = (UserDebugReportCallbackData *)pUserData;
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT_LOCAL(CreateInfo, *pCreateInfo).Important();
+  SERIALISE_ELEMENT_OPT(pAllocator);
+  SERIALISE_ELEMENT_LOCAL(accelerationStructure, GetResID(*pAccelerationStructure))
+      .TypedAs("VkAccelerationStructureKHR"_lit);
 
-  if(RenderDoc::Inst().GetCaptureOptions().debugOutputMute)
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
   {
-    if(user->muteWarned)
-      return false;
+    VkAccelerationStructureKHR as = VK_NULL_HANDLE;
 
-    // once only insert a fake message notifying of the muting
-    user->muteWarned = true;
+    VkResult ret =
+        ObjDisp(device)->CreateAccelerationStructureKHR(Unwrap(device), &CreateInfo, NULL, &as);
 
-    // we insert as an information message, since some trigger-happy applications might
-    // debugbreak/crash/messagebox/etc on even warnings. This puts us in the same pool
-    // as extremely spammy messages, but there's not much alternative.
-    if(user->createInfo.flags & (VK_DEBUG_REPORT_INFORMATION_BIT_EXT | VK_DEBUG_REPORT_DEBUG_BIT_EXT))
+    if(ret != VK_SUCCESS)
     {
-      // use information type if possible, or if it's not accepted but debug is - use debug type.
-      flags = (user->createInfo.flags & VK_DEBUG_REPORT_INFORMATION_BIT_EXT)
-                  ? VK_DEBUG_REPORT_INFORMATION_BIT_EXT
-                  : VK_DEBUG_REPORT_DEBUG_BIT_EXT;
+      SET_ERROR_RESULT(m_FailedReplayResult, ResultCode::APIReplayFailed,
+                       "Error creating acceleration structure, VkResult: %s", ToStr(ret).c_str());
+      return false;
+    }
+    else
+    {
+      ResourceId live;
 
-      user->createInfo.pfnCallback(flags, VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
-                                   (uint64_t)user->wrappedInstance, 1, 1, "RDOC",
-                                   "While debugging through RenderDoc, debug output through "
-                                   "validation layers is suppressed.\n"
-                                   "To show debug output look at the 'DebugOutputMute' capture "
-                                   "option in RenderDoc's API, but "
-                                   "be aware of false positives from the validation layers.",
-                                   user->createInfo.pUserData);
+      if(GetResourceManager()->HasWrapper(ToTypedHandle(as)))
+      {
+        live = GetResourceManager()->GetNonDispWrapper(as)->id;
+
+        // destroy this instance of the duplicate, as we must have matching create/destroy
+        // calls and there won't be a wrapped resource hanging around to destroy this one.
+        ObjDisp(device)->DestroyAccelerationStructureKHR(Unwrap(device), as, NULL);
+
+        // whenever the new ID is requested, return the old ID, via replacements.
+        GetResourceManager()->ReplaceResource(accelerationStructure,
+                                              GetResourceManager()->GetOriginalID(live));
+      }
+      else
+      {
+        live = GetResourceManager()->WrapResource(Unwrap(device), as);
+        GetResourceManager()->AddLiveResource(accelerationStructure, as);
+
+        // m_CreationInfo.m_AccelerationStructure[live].Init(GetResourceManager(), m_CreationInfo, &CreateInfo);
+      }
     }
 
-    return false;
+    // AddResource(accelerationStructure, ResourceType::AccelerationStructure, "Acceleration Structure");
+    DerivedResource(device, accelerationStructure);
   }
 
-  return user->createInfo.pfnCallback(flags, objectType, object, location, messageCode,
-                                      pLayerPrefix, pMessage, user->createInfo.pUserData);
+  return true;
 }
 
-VkBool32 VKAPI_PTR UserDebugUtilsCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
-                                          VkDebugUtilsMessageTypeFlagsEXT messageType,
-                                          const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData,
-                                          void *pUserData)
+VkResult WrappedVulkan::vkCreateAccelerationStructureKHR(
+    VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo,
+    const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure)
 {
-  UserDebugUtilsCallbackData *user = (UserDebugUtilsCallbackData *)pUserData;
+  VkResult ret;
+  SERIALISE_TIME_CALL(ret = ObjDisp(device)->CreateAccelerationStructureKHR(
+                          Unwrap(device), pCreateInfo, pAllocator, pAccelerationStructure));
 
-  if(RenderDoc::Inst().GetCaptureOptions().debugOutputMute)
+  if(ret == VK_SUCCESS)
   {
-    if(user->muteWarned)
-      return false;
-
-    // once only insert a fake message notifying of the muting
-    user->muteWarned = true;
+    ResourceId id = GetResourceManager()->WrapResource(Unwrap(device), *pAccelerationStructure);
 
-    // we insert as an information message, since some trigger-happy applications might
-    // debugbreak/crash/messagebox/etc on even warnings. This puts us in the same pool
-    // as extremely spammy messages, but there's not much alternative.
-    if(user->createInfo.messageSeverity & (VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
-                                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT))
+    if(IsCaptureMode(m_State))
     {
-      // use information type if possible, or if it's not accepted but debug is - use debug type.
-      messageSeverity =
-          (user->createInfo.messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT)
-              ? VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT
-              : VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
+      Chunk *chunk = NULL;
 
-      VkDebugUtilsMessengerCallbackDataEXT data = {};
+      {
+        CACHE_THREAD_SERIALISER();
 
-      data.messageIdNumber = 1;
-      data.pMessageIdName = NULL;
-      data.pMessage =
-          "While debugging through RenderDoc, debug output through validation layers is "
-          "suppressed.\n"
-          "To show debug output look at the 'DebugOutputMute' capture option in RenderDoc's API, "
-          "but be aware of false positives from the validation layers.";
-      data.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
+        SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCreateAccelerationStructureKHR);
+        Serialise_vkCreateAccelerationStructureKHR(ser, device, pCreateInfo, NULL,
+                                                   pAccelerationStructure);
 
-      user->createInfo.pfnUserCallback(messageSeverity, VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
-                                       &data, user->createInfo.pUserData);
-    }
+        chunk = scope.Get();
+      }
 
-    return false;
+      VkResourceRecord *record = GetResourceManager()->AddResourceRecord(*pAccelerationStructure);
+      record->AddChunk(chunk);
+    }
+    else
+    {
+      GetResourceManager()->AddLiveResource(id, *pAccelerationStructure);
+    }
   }
 
-  return user->createInfo.pfnUserCallback(messageSeverity, messageType, pCallbackData,
-                                          user->createInfo.pUserData);
+  return ret;
 }
 
-VkResult WrappedVulkan::vkCreateDebugReportCallbackEXT(
-    VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo,
-    const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback)
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCmdBuildAccelerationStructuresKHR(
+    SerialiserType &ser, VkCommandBuffer commandBuffer, uint32_t infoCount,
+    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
+    const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
 {
-  // we create an interception object here so that we can dynamically check the state of API
-  // messages being muted, since it's quite likely that the application will initialise Vulkan (and
-  // so create a debug report callback) before it messes with RenderDoc's API to unmute messages.
-  UserDebugReportCallbackData *user = new UserDebugReportCallbackData();
-  user->wrappedInstance = instance;
-  user->createInfo = *pCreateInfo;
-  user->muteWarned = false;
+  SERIALISE_ELEMENT(commandBuffer);
+  SERIALISE_ELEMENT(infoCount);
 
-  VkDebugReportCallbackCreateInfoEXT wrappedCreateInfo = *pCreateInfo;
-  wrappedCreateInfo.pfnCallback = &UserDebugReportCallback;
-  wrappedCreateInfo.pUserData = user;
+  SERIALISE_ELEMENT_LOCAL(infos, pInfos).Important();
 
-  VkResult vkr = ObjDisp(instance)->CreateDebugReportCallbackEXT(
-      Unwrap(instance), &wrappedCreateInfo, pAllocator, &user->realObject);
+  SERIALISE_ELEMENT_LOCAL(buildRangeInfos, ppBuildRangeInfos).Important();
 
-  if(vkr != VK_SUCCESS)
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
   {
-    *pCallback = VK_NULL_HANDLE;
-    delete user;
-    return vkr;
+    ObjDisp(commandBuffer)
+        ->CmdBuildAccelerationStructuresKHR(Unwrap(commandBuffer), infoCount, infos, buildRangeInfos);
   }
 
+  SAFE_DELETE_ARRAY(infos);
+  SAFE_DELETE_ARRAY(buildRangeInfos);
+
+  return true;
+}
+
+void WrappedVulkan::vkCmdBuildAccelerationStructuresKHR(
+    VkCommandBuffer commandBuffer, uint32_t infoCount,
+    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
+    const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
+{
+  SERIALISE_TIME_CALL(ObjDisp(commandBuffer)
+                          ->CmdBuildAccelerationStructuresKHR(Unwrap(commandBuffer), infoCount,
+                                                              pInfos, ppBuildRangeInfos));
+
+  if(IsCaptureMode(m_State))
   {
-    SCOPED_LOCK(m_CallbacksLock);
-    m_ReportCallbacks.push_back(user);
-  }
+    Chunk *chunk = NULL;
 
-  *pCallback = (VkDebugReportCallbackEXT)(uint64_t)user;
+    {
+      CACHE_THREAD_SERIALISER();
 
-  return vkr;
+      SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCmdBuildAccelerationStructuresKHR);
+      Serialise_vkCmdBuildAccelerationStructuresKHR(ser, commandBuffer, infoCount, pInfos,
+                                                    ppBuildRangeInfos);
+
+      chunk = scope.Get();
+    }
+
+    VkResourceRecord *record = GetResourceManager()->GetResourceRecord(GetResID(commandBuffer));
+    RDCASSERT(record);
+
+    record->AddChunk(chunk);
+    // record->MarkResourceFrameReferenced(GetResID(commandBuffer), eFrameRef_Write);
+  }
 }
 
-void WrappedVulkan::vkDestroyDebugReportCallbackEXT(VkInstance instance,
-                                                    VkDebugReportCallbackEXT callback,
-                                                    const VkAllocationCallbacks *pAllocator)
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCmdBuildAccelerationStructuresIndirectKHR(
+    SerialiserType &ser, VkCommandBuffer commandBuffer, uint32_t infoCount,
+    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
+    const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides,
+    const uint32_t *const *ppMaxPrimitiveCounts)
 {
-  if(callback == VK_NULL_HANDLE)
-    return;
+  SERIALISE_ELEMENT(commandBuffer);
+  SERIALISE_ELEMENT(infoCount);
 
-  UserDebugReportCallbackData *user =
-      (UserDebugReportCallbackData *)(uintptr_t)NON_DISP_TO_UINT64(callback);
+  SERIALISE_ELEMENT_LOCAL(infos, pInfos).Important();
 
-  ObjDisp(instance)->DestroyDebugReportCallbackEXT(Unwrap(instance), user->realObject, pAllocator);
+  SERIALISE_ELEMENT_LOCAL(indirectDeviceAddresses, pIndirectDeviceAddresses).Important();
+
+  SERIALISE_ELEMENT_LOCAL(indirectStrides, pIndirectStrides).Important();
+
+  SERIALISE_ELEMENT_LOCAL(maxPrimitiveCounts, ppMaxPrimitiveCounts).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
 
+  if(IsReplayingAndReading())
   {
-    SCOPED_LOCK(m_CallbacksLock);
-    m_ReportCallbacks.removeOne(user);
+    ObjDisp(commandBuffer)
+        ->CmdBuildAccelerationStructuresIndirectKHR(Unwrap(commandBuffer), infoCount, infos,
+                                                    indirectDeviceAddresses, indirectStrides,
+                                                    maxPrimitiveCounts);
   }
 
-  delete user;
+  SAFE_DELETE_ARRAY(infos);
+  SAFE_DELETE_ARRAY(indirectDeviceAddresses);
+  SAFE_DELETE_ARRAY(indirectStrides);
+  SAFE_DELETE_ARRAY(maxPrimitiveCounts);
+
+  return true;
 }
 
-void WrappedVulkan::vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags,
-                                            VkDebugReportObjectTypeEXT objectType, uint64_t object,
-                                            size_t location, int32_t messageCode,
-                                            const char *pLayerPrefix, const char *pMessage)
+void WrappedVulkan::vkCmdBuildAccelerationStructuresIndirectKHR(
+    VkCommandBuffer commandBuffer, uint32_t infoCount,
+    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
+    const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides,
+    const uint32_t *const *ppMaxPrimitiveCounts)
 {
-  return ObjDisp(instance)->DebugReportMessageEXT(Unwrap(instance), flags, objectType, object,
-                                                  location, messageCode, pLayerPrefix, pMessage);
+  SERIALISE_TIME_CALL(ObjDisp(commandBuffer)
+                          ->CmdBuildAccelerationStructuresIndirectKHR(
+                              Unwrap(commandBuffer), infoCount, pInfos, pIndirectDeviceAddresses,
+                              pIndirectStrides, ppMaxPrimitiveCounts));
+
+  if(IsCaptureMode(m_State))
+  {
+    Chunk *chunk = NULL;
+
+    {
+      CACHE_THREAD_SERIALISER();
+
+      SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCmdBuildAccelerationStructuresIndirectKHR);
+      Serialise_vkCmdBuildAccelerationStructuresIndirectKHR(ser, commandBuffer, infoCount, pInfos,
+                                                            pIndirectDeviceAddresses,
+                                                            pIndirectStrides, ppMaxPrimitiveCounts);
+
+      chunk = scope.Get();
+    }
+
+    VkResourceRecord *record = GetResourceManager()->GetResourceRecord(GetResID(commandBuffer));
+    RDCASSERT(record);
+
+    record->AddChunk(chunk);
+    // record->MarkResourceFrameReferenced(GetResID(commandBuffer), eFrameRef_Write);
+  }
 }
 
-void WrappedVulkan::vkSetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount,
-                                        const VkSwapchainKHR *pSwapchains,
-                                        const VkHdrMetadataEXT *pMetadata)
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkBuildAccelerationStructuresKHR(
+    SerialiserType &ser, VkDevice device, VkDeferredOperationKHR deferredOperation,
+    uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
+    const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
 {
-  return ObjDisp(device)->SetHdrMetadataEXT(Unwrap(device), swapchainCount,
-                                            UnwrapArray(pSwapchains, swapchainCount), pMetadata);
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT(deferredOperation).Important();
+  SERIALISE_ELEMENT(infoCount);
+
+  SERIALISE_ELEMENT_LOCAL(infos, pInfos).Important();
+
+  SERIALISE_ELEMENT_LOCAL(buildRangeInfos, ppBuildRangeInfos).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->BuildAccelerationStructuresKHR(Unwrap(device), Unwrap(deferredOperation),
+                                                    infoCount, infos, buildRangeInfos);
+  }
+
+  SAFE_DELETE_ARRAY(infos);
+  SAFE_DELETE_ARRAY(buildRangeInfos);
+
+  return true;
 }
 
-void WrappedVulkan::vkSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain,
-                                         VkBool32 localDimmingEnable)
+VkResult WrappedVulkan::vkBuildAccelerationStructuresKHR(
+    VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount,
+    const VkAccelerationStructureBuildGeometryInfoKHR *pInfos,
+    const VkAccelerationStructureBuildRangeInfoKHR *const *ppBuildRangeInfos)
 {
-  return ObjDisp(device)->SetLocalDimmingAMD(Unwrap(device), Unwrap(swapChain), localDimmingEnable);
+  VkResult ret;
+  SERIALISE_TIME_CALL(
+      ret = ObjDisp(device)->BuildAccelerationStructuresKHR(
+          Unwrap(device), Unwrap(deferredOperation), infoCount, pInfos, ppBuildRangeInfos));
+
+  if(ret == VK_SUCCESS)
+  {
+    if(IsCaptureMode(m_State))
+    {
+      Chunk *chunk = NULL;
+
+      {
+        CACHE_THREAD_SERIALISER();
+
+        SCOPED_SERIALISE_CHUNK(VulkanChunk::vkBuildAccelerationStructuresKHR);
+        Serialise_vkBuildAccelerationStructuresKHR(ser, device, deferredOperation, infoCount,
+                                                   pInfos, ppBuildRangeInfos);
+
+        chunk = scope.Get();
+      }
+
+      VkResourceRecord *record = GetResourceManager()->AddResourceRecord(deferredOperation);
+      record->AddChunk(chunk);
+    }
+  }
+
+  return ret;
 }
 
-// we use VkObjectType as the object type since it mostly overlaps with the debug report enum so in
-// most cases we can upcast it. There's an overload to translate the few that might conflict.
-// Likewise to re-use the switch in most cases, we return both the record and the unwrapped
-// object at once. In *most* cases the unwrapped object comes from the record, but there are a few
-// exceptions which don't have records, or aren't wrapped, etc.
-struct ObjData
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCopyAccelerationStructureKHR(
+    SerialiserType &ser, VkDevice device, VkDeferredOperationKHR deferredOperation,
+    const VkCopyAccelerationStructureInfoKHR *pInfo)
 {
-  VkResourceRecord *record;
-  uint64_t unwrapped;
-};
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT(deferredOperation).Important();
+  SERIALISE_ELEMENT_LOCAL(info, pInfo).Important();
 
-static ObjData GetObjData(VkObjectType objType, uint64_t object)
-{
-  ObjData ret = {};
+  SERIALISE_CHECK_READ_ERRORS();
 
-  switch(objType)
+  if(IsReplayingAndReading())
   {
-    case VK_OBJECT_TYPE_INSTANCE: ret.record = GetRecord((VkInstance)object); break;
-    case VK_OBJECT_TYPE_PHYSICAL_DEVICE: ret.record = GetRecord((VkPhysicalDevice)object); break;
-    case VK_OBJECT_TYPE_DEVICE: ret.record = GetRecord((VkDevice)object); break;
-    case VK_OBJECT_TYPE_QUEUE: ret.record = GetRecord((VkQueue)object); break;
-    case VK_OBJECT_TYPE_SEMAPHORE: ret.record = GetRecord((VkSemaphore)object); break;
+    ObjDisp(device)->CopyAccelerationStructureKHR(Unwrap(device), Unwrap(deferredOperation), info);
+  }
+
+  SAFE_DELETE_ARRAY(info);
+
+  return true;
+}
+
+VkResult WrappedVulkan::vkCopyAccelerationStructureKHR(VkDevice device,
+                                                       VkDeferredOperationKHR deferredOperation,
+                                                       const VkCopyAccelerationStructureInfoKHR *pInfo)
+{
+  VkResult ret;
+  SERIALISE_TIME_CALL(ret = ObjDisp(device)->CopyAccelerationStructureKHR(
+                          Unwrap(device), Unwrap(deferredOperation), pInfo));
+
+  if(ret == VK_SUCCESS)
+  {
+    if(IsCaptureMode(m_State))
+    {
+      Chunk *chunk = NULL;
+
+      {
+        CACHE_THREAD_SERIALISER();
+
+        SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCopyAccelerationStructureKHR);
+        Serialise_vkCopyAccelerationStructureKHR(ser, device, deferredOperation, pInfo);
+
+        chunk = scope.Get();
+      }
+
+      VkResourceRecord *record = GetResourceManager()->AddResourceRecord(deferredOperation);
+      record->AddChunk(chunk);
+    }
+  }
+
+  return ret;
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCopyAccelerationStructureToMemoryKHR(
+    SerialiserType &ser, VkDevice device, VkDeferredOperationKHR deferredOperation,
+    const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
+{
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT(deferredOperation).Important();
+  SERIALISE_ELEMENT_LOCAL(info, pInfo).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->CopyAccelerationStructureToMemoryKHR(Unwrap(device), Unwrap(deferredOperation),
+                                                          info);
+  }
+
+  SAFE_DELETE_ARRAY(info);
+
+  return true;
+}
+
+VkResult WrappedVulkan::vkCopyAccelerationStructureToMemoryKHR(
+    VkDevice device, VkDeferredOperationKHR deferredOperation,
+    const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
+{
+  VkResult ret;
+  SERIALISE_TIME_CALL(ret = ObjDisp(device)->CopyAccelerationStructureToMemoryKHR(
+                          Unwrap(device), Unwrap(deferredOperation), pInfo));
+
+  if(ret == VK_SUCCESS)
+  {
+    if(IsCaptureMode(m_State))
+    {
+      Chunk *chunk = NULL;
+
+      {
+        CACHE_THREAD_SERIALISER();
+
+        SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCopyAccelerationStructureToMemoryKHR);
+        Serialise_vkCopyAccelerationStructureToMemoryKHR(ser, device, deferredOperation, pInfo);
+
+        chunk = scope.Get();
+      }
+
+      VkResourceRecord *record = GetResourceManager()->AddResourceRecord(deferredOperation);
+      record->AddChunk(chunk);
+    }
+  }
+
+  return ret;
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCopyMemoryToAccelerationStructureKHR(
+    SerialiserType &ser, VkDevice device, VkDeferredOperationKHR deferredOperation,
+    const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
+{
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT(deferredOperation).Important();
+  SERIALISE_ELEMENT_LOCAL(info, pInfo).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->CopyMemoryToAccelerationStructureKHR(Unwrap(device), Unwrap(deferredOperation),
+                                                          info);
+  }
+
+  SAFE_DELETE_ARRAY(info);
+
+  return true;
+}
+
+VkResult WrappedVulkan::vkCopyMemoryToAccelerationStructureKHR(
+    VkDevice device, VkDeferredOperationKHR deferredOperation,
+    const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
+{
+  VkResult ret;
+  SERIALISE_TIME_CALL(ret = ObjDisp(device)->CopyMemoryToAccelerationStructureKHR(
+                          Unwrap(device), Unwrap(deferredOperation), pInfo));
+
+  if(ret == VK_SUCCESS)
+  {
+    if(IsCaptureMode(m_State))
+    {
+      Chunk *chunk = NULL;
+
+      {
+        CACHE_THREAD_SERIALISER();
+
+        SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCopyMemoryToAccelerationStructureKHR);
+        Serialise_vkCopyMemoryToAccelerationStructureKHR(ser, device, deferredOperation, pInfo);
+
+        chunk = scope.Get();
+      }
+
+      VkResourceRecord *record = GetResourceManager()->AddResourceRecord(deferredOperation);
+      record->AddChunk(chunk);
+    }
+  }
+
+  return ret;
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkWriteAccelerationStructuresPropertiesKHR(
+    SerialiserType &ser, VkDevice device, uint32_t accelerationStructureCount,
+    const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType,
+    size_t dataSize, void *pData, size_t stride)
+{
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT(accelerationStructureCount);
+  SERIALISE_ELEMENT_LOCAL(accelerationStructures, pAccelerationStructures).Important();
+  SERIALISE_ELEMENT(queryType);
+  SERIALISE_ELEMENT(dataSize);
+  SERIALISE_ELEMENT_LOCAL(data, pData).Important();
+  SERIALISE_ELEMENT(stride);
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->WriteAccelerationStructuresPropertiesKHR(
+        Unwrap(device), accelerationStructureCount, accelerationStructures, queryType, dataSize,
+        pData, stride);
+  }
+
+  SAFE_DELETE_ARRAY(accelerationStructures);
+  SAFE_DELETE_ARRAY(data);
+
+  return true;
+}
+
+VkResult WrappedVulkan::vkWriteAccelerationStructuresPropertiesKHR(
+    VkDevice device, uint32_t accelerationStructureCount,
+    const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType,
+    size_t dataSize, void *pData, size_t stride)
+{
+  VkResult ret;
+  SERIALISE_TIME_CALL(ret = ObjDisp(device)->WriteAccelerationStructuresPropertiesKHR(
+                          Unwrap(device), accelerationStructureCount, pAccelerationStructures,
+                          queryType, dataSize, pData, stride));
+
+  if(ret == VK_SUCCESS)
+  {
+    if(IsCaptureMode(m_State))
+    {
+      CACHE_THREAD_SERIALISER();
+
+      SCOPED_SERIALISE_CHUNK(VulkanChunk::vkWriteAccelerationStructuresPropertiesKHR);
+      Serialise_vkWriteAccelerationStructuresPropertiesKHR(ser, device, accelerationStructureCount,
+                                                           pAccelerationStructures, queryType,
+                                                           dataSize, pData, stride);
+
+      m_FrameCaptureRecord->AddChunk(scope.Get());
+      GetResourceManager()->MarkResourceFrameReferenced(GetResID(*pAccelerationStructures),
+                                                        eFrameRef_Read);
+    }
+  }
+
+  return ret;
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCmdCopyAccelerationStructureKHR(
+    SerialiserType &ser, VkCommandBuffer commandBuffer,
+    const VkCopyAccelerationStructureInfoKHR *pInfo)
+{
+  SERIALISE_ELEMENT(commandBuffer);
+  SERIALISE_ELEMENT_LOCAL(info, pInfo).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(commandBuffer)->CmdCopyAccelerationStructureKHR(Unwrap(commandBuffer), info);
+  }
+
+  SAFE_DELETE_ARRAY(info);
+
+  return true;
+}
+
+void WrappedVulkan::vkCmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer,
+                                                      const VkCopyAccelerationStructureInfoKHR *pInfo)
+{
+  SERIALISE_TIME_CALL(
+      ObjDisp(commandBuffer)->CmdCopyAccelerationStructureKHR(Unwrap(commandBuffer), pInfo));
+
+  if(IsCaptureMode(m_State))
+  {
+    Chunk *chunk = NULL;
+
+    {
+      CACHE_THREAD_SERIALISER();
+
+      SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCmdCopyAccelerationStructureKHR);
+      Serialise_vkCmdCopyAccelerationStructureKHR(ser, commandBuffer, pInfo);
+
+      chunk = scope.Get();
+    }
+
+    VkResourceRecord *record = GetResourceManager()->GetResourceRecord(GetResID(commandBuffer));
+    RDCASSERT(record);
+
+    record->AddChunk(chunk);
+    // record->MarkResourceFrameReferenced(GetResID(commandBuffer), eFrameRef_Write);
+  }
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCmdCopyAccelerationStructureToMemoryKHR(
+    SerialiserType &ser, VkCommandBuffer commandBuffer,
+    const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
+{
+  SERIALISE_ELEMENT(commandBuffer);
+  SERIALISE_ELEMENT_LOCAL(info, pInfo).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(commandBuffer)->CmdCopyAccelerationStructureToMemoryKHR(Unwrap(commandBuffer), info);
+  }
+
+  SAFE_DELETE_ARRAY(info);
+
+  return true;
+}
+
+void WrappedVulkan::vkCmdCopyAccelerationStructureToMemoryKHR(
+    VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo)
+{
+  SERIALISE_TIME_CALL(
+      ObjDisp(commandBuffer)->CmdCopyAccelerationStructureToMemoryKHR(Unwrap(commandBuffer), pInfo));
+
+  if(IsCaptureMode(m_State))
+  {
+    Chunk *chunk = NULL;
+
+    {
+      CACHE_THREAD_SERIALISER();
+
+      SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCmdCopyAccelerationStructureToMemoryKHR);
+      Serialise_vkCmdCopyAccelerationStructureToMemoryKHR(ser, commandBuffer, pInfo);
+
+      chunk = scope.Get();
+    }
+
+    VkResourceRecord *record = GetResourceManager()->GetResourceRecord(GetResID(commandBuffer));
+    RDCASSERT(record);
+
+    record->AddChunk(chunk);
+    // record->MarkResourceFrameReferenced(GetResID(commandBuffer), eFrameRef_Write);
+  }
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCmdCopyMemoryToAccelerationStructureKHR(
+    SerialiserType &ser, VkCommandBuffer commandBuffer,
+    const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
+{
+  SERIALISE_ELEMENT(commandBuffer);
+  SERIALISE_ELEMENT_LOCAL(info, pInfo).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(commandBuffer)->CmdCopyMemoryToAccelerationStructureKHR(Unwrap(commandBuffer), info);
+  }
+
+  SAFE_DELETE_ARRAY(info);
+
+  return true;
+}
+
+void WrappedVulkan::vkCmdCopyMemoryToAccelerationStructureKHR(
+    VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo)
+{
+  SERIALISE_TIME_CALL(
+      ObjDisp(commandBuffer)->CmdCopyMemoryToAccelerationStructureKHR(Unwrap(commandBuffer), pInfo));
+
+  if(IsCaptureMode(m_State))
+  {
+    Chunk *chunk = NULL;
+
+    {
+      CACHE_THREAD_SERIALISER();
+
+      SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCmdCopyMemoryToAccelerationStructureKHR);
+      Serialise_vkCmdCopyMemoryToAccelerationStructureKHR(ser, commandBuffer, pInfo);
+
+      chunk = scope.Get();
+    }
+
+    VkResourceRecord *record = GetResourceManager()->GetResourceRecord(GetResID(commandBuffer));
+    RDCASSERT(record);
+
+    record->AddChunk(chunk);
+    // record->MarkResourceFrameReferenced(GetResID(commandBuffer), eFrameRef_Write);
+  }
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkGetAccelerationStructureDeviceAddressKHR(
+    SerialiserType &ser, VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo)
+{
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT_LOCAL(info, pInfo).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->GetAccelerationStructureDeviceAddressKHR(Unwrap(device), info);
+  }
+
+  SAFE_DELETE_ARRAY(info);
+
+  return true;
+}
+
+VkDeviceAddress WrappedVulkan::vkGetAccelerationStructureDeviceAddressKHR(
+    VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo)
+{
+  VkDeviceAddress ret;
+  SERIALISE_TIME_CALL(
+      ret = ObjDisp(device)->GetAccelerationStructureDeviceAddressKHR(Unwrap(device), pInfo));
+
+  if(IsActiveCapturing(m_State))
+  {
+    CACHE_THREAD_SERIALISER();
+
+    SCOPED_SERIALISE_CHUNK(VulkanChunk::vkGetAccelerationStructureDeviceAddressKHR);
+    Serialise_vkGetAccelerationStructureDeviceAddressKHR(ser, device, pInfo);
+
+    m_FrameCaptureRecord->AddChunk(scope.Get());
+    GetResourceManager()->MarkResourceFrameReferenced(GetResID(pInfo->accelerationStructure),
+                                                      eFrameRef_Read);
+  }
+
+  return ret;
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCmdWriteAccelerationStructuresPropertiesKHR(
+    SerialiserType &ser, VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount,
+    const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType,
+    VkQueryPool queryPool, uint32_t firstQuery)
+{
+  SERIALISE_ELEMENT(commandBuffer);
+  SERIALISE_ELEMENT(accelerationStructureCount);
+  SERIALISE_ELEMENT_LOCAL(accelerationStructures, pAccelerationStructures).Important();
+  SERIALISE_ELEMENT(queryType);
+  SERIALISE_ELEMENT(queryPool).Important();
+  SERIALISE_ELEMENT(firstQuery);
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(commandBuffer)
+        ->CmdWriteAccelerationStructuresPropertiesKHR(
+            Unwrap(commandBuffer), accelerationStructureCount, accelerationStructures, queryType,
+            Unwrap(queryPool), firstQuery);
+  }
+
+  SAFE_DELETE_ARRAY(accelerationStructures);
+
+  return true;
+}
+
+void WrappedVulkan::vkCmdWriteAccelerationStructuresPropertiesKHR(
+    VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount,
+    const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType,
+    VkQueryPool queryPool, uint32_t firstQuery)
+{
+  SERIALISE_TIME_CALL(ObjDisp(commandBuffer)
+                          ->CmdWriteAccelerationStructuresPropertiesKHR(
+                              Unwrap(commandBuffer), accelerationStructureCount,
+                              pAccelerationStructures, queryType, Unwrap(queryPool), firstQuery));
+
+  if(IsActiveCapturing(m_State))
+  {
+    CACHE_THREAD_SERIALISER();
+
+    SCOPED_SERIALISE_CHUNK(VulkanChunk::vkCmdWriteAccelerationStructuresPropertiesKHR);
+    Serialise_vkCmdWriteAccelerationStructuresPropertiesKHR(
+        ser, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType,
+        queryPool, firstQuery);
+
+    m_FrameCaptureRecord->AddChunk(scope.Get());
+    GetResourceManager()->MarkResourceFrameReferenced(GetResID(*pAccelerationStructures),
+                                                      eFrameRef_Read);
+  }
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkGetDeviceAccelerationStructureCompatibilityKHR(
+    SerialiserType &ser, VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo,
+    VkAccelerationStructureCompatibilityKHR *pCompatibility)
+{
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT_LOCAL(info, pVersionInfo).Important();
+  SERIALISE_ELEMENT_LOCAL(compat, pCompatibility).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->GetDeviceAccelerationStructureCompatibilityKHR(Unwrap(device), info, compat);
+  }
+
+  SAFE_DELETE_ARRAY(info);
+  SAFE_DELETE_ARRAY(compat);
+
+  return true;
+}
+
+void WrappedVulkan::vkGetDeviceAccelerationStructureCompatibilityKHR(
+    VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo,
+    VkAccelerationStructureCompatibilityKHR *pCompatibility)
+{
+  SERIALISE_TIME_CALL(ObjDisp(device)->GetDeviceAccelerationStructureCompatibilityKHR(
+      Unwrap(device), pVersionInfo, pCompatibility));
+
+  if(IsActiveCapturing(m_State))
+  {
+    CACHE_THREAD_SERIALISER();
+
+    SCOPED_SERIALISE_CHUNK(VulkanChunk::vkGetDeviceAccelerationStructureCompatibilityKHR);
+    Serialise_vkGetDeviceAccelerationStructureCompatibilityKHR(ser, device, pVersionInfo,
+                                                               pCompatibility);
+
+    m_FrameCaptureRecord->AddChunk(scope.Get());
+  }
+}
+
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkGetAccelerationStructureBuildSizesKHR(
+    SerialiserType &ser, VkDevice device, VkAccelerationStructureBuildTypeKHR buildType,
+    const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo,
+    const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo)
+{
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT(buildType);
+  SERIALISE_ELEMENT_LOCAL(info, pBuildInfo).Important();
+  SERIALISE_ELEMENT_LOCAL(maxPrimitiveCounts, pMaxPrimitiveCounts).Important();
+  SERIALISE_ELEMENT_LOCAL(sizeInfo, pSizeInfo).Important();
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->GetAccelerationStructureBuildSizesKHR(Unwrap(device), buildType, info,
+                                                           maxPrimitiveCounts, sizeInfo);
+  }
+
+  SAFE_DELETE_ARRAY(info);
+  SAFE_DELETE_ARRAY(maxPrimitiveCounts);
+  SAFE_DELETE_ARRAY(sizeInfo);
+
+  return true;
+}
+
+void WrappedVulkan::vkGetAccelerationStructureBuildSizesKHR(
+    VkDevice device, VkAccelerationStructureBuildTypeKHR buildType,
+    const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo,
+    const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo)
+{
+  SERIALISE_TIME_CALL(ObjDisp(device)->GetAccelerationStructureBuildSizesKHR(
+      Unwrap(device), buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo));
+
+  if(IsActiveCapturing(m_State))
+  {
+    CACHE_THREAD_SERIALISER();
+
+    SCOPED_SERIALISE_CHUNK(VulkanChunk::vkGetAccelerationStructureBuildSizesKHR);
+    Serialise_vkGetAccelerationStructureBuildSizesKHR(ser, device, buildType, pBuildInfo,
+                                                      pMaxPrimitiveCounts, pSizeInfo);
+
+    m_FrameCaptureRecord->AddChunk(scope.Get());
+  }
+}
+
+//VK_KHR_deferred_host_operations
+template <typename SerialiserType>
+bool WrappedVulkan::Serialise_vkCreateDeferredOperationKHR(
+    SerialiserType &ser, VkDevice device,
+    const VkAllocationCallbacks* pAllocator,
+    VkDeferredOperationKHR* pDeferredOperation)
+{
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT_OPT(pAllocator);
+  SERIALISE_ELEMENT_LOCAL(operation, GetResID(*pDeferredOperation))
+      .TypedAs("vkDeferredOperationKHR"_lit);
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    vkCreateDeferredOperationKHR do = VK_NULL_HANDLE;
+
+    VkResult ret =
+        ObjDisp(device)->CreateDeferredOperationKHR(Unwrap(device), NULL, &do);
+
+    if(ret != VK_SUCCESS)
+    {
+      SET_ERROR_RESULT(m_FailedReplayResult, ResultCode::APIReplayFailed,
+                       "Error creating Deferred Operation, VkResult: %s", ToStr(ret).c_str());
+      return false;
+    }
+    else
+    {
+      ResourceId live;
+
+      if(GetResourceManager()->HasWrapper(ToTypedHandle(do)))
+      {
+        live = GetResourceManager()->GetNonDispWrapper(do)->id;
+
+        // destroy this instance of the duplicate, as we must have matching create/destroy
+        // calls and there won't be a wrapped resource hanging around to destroy this one.
+        ObjDisp(device)->DestroyDeferredOperationKHR(Unwrap(device), do, NULL);
+
+        // whenever the new ID is requested, return the old ID, via replacements.
+        GetResourceManager()->ReplaceResource(operation,
+                                              GetResourceManager()->GetOriginalID(live));
+      }
+      else
+      {
+        live = GetResourceManager()->WrapResource(Unwrap(device), do);
+        GetResourceManager()->AddLiveResource(operation, do);
+
+        //m_CreationInfo.m_YCbCrSampler[live].Init(GetResourceManager(), m_CreationInfo, &CreateInfo);
+      }
+    }
+
+    //AddResource(operation, ResourceType::Sampler, "YCbCr Sampler");
+    DerivedResource(device, operation);
+  }
+
+  return true;
+}
+
+VkResult WrappedVulkan::vkCreateDeferredOperationKHR(VkDevice device,
+    const VkAllocationCallbacks* pAllocator,
+    VkDeferredOperationKHR* pDeferredOperation)
+{
+  return ObjDisp(device)->CreateDeferredOperationKHR(Unwrap(device), pAllocator, pDeferredOperation);
+}
+
+template <typename SerialiserType>
+ bool WrappedVulkan::Serialise_vkGetDeferredOperationMaxConcurrencyKHR(
+     SerialiserType &ser, VkDevice device,
+     VkDeferredOperationKHR operation)
+ {
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT(operation);
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->GetDeferredOperationMaxConcurrencyKHR(Unwrap(device), operation);
+  }
+
+  return true;
+ }
+
+ uint32_t WrappedVulkan::vkGetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation)
+{
+  return ObjDisp(device)->GetDeferredOperationMaxConcurrencyKHR(Unwrap(device), operation);
+ }
+
+ template <typename SerialiserType>
+ bool WrappedVulkan::Serialise_vkGetDeferredOperationResultKHR(
+     SerialiserType &ser, VkDevice device, VkDeferredOperationKHR operation)
+ {
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT(operation);
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->GetDeferredOperationResultKHR(Unwrap(device), operation);
+  }
+
+  return true;
+ }
+
+ VkResult WrappedVulkan::vkGetDeferredOperationResultKHR(VkDevice device,
+    VkDeferredOperationKHR operation)
+{
+  return ObjDisp(device)->GetDeferredOperationResultKHR(Unwrap(device), operation);
+
+ }
+
+ template <typename SerialiserType>
+ bool WrappedVulkan::Serialise_vkDeferredOperationJoinKHR(
+     SerialiserType &ser, VkDevice device, VkDeferredOperationKHR operation)
+ {
+  SERIALISE_ELEMENT(device);
+  SERIALISE_ELEMENT(operation);
+
+  SERIALISE_CHECK_READ_ERRORS();
+
+  if(IsReplayingAndReading())
+  {
+    ObjDisp(device)->DeferredOperationJoinKHR(Unwrap(device), operation);
+  }
+
+  return true;
+ }
+
+ VkResult WrappedVulkan::vkDeferredOperationJoinKHR(VkDevice device,
+    VkDeferredOperationKHR operation)
+{
+  return ObjDisp(device)->DeferredOperationJoinKHR(Unwrap(device), operation);
+
+ }
+
+
+VkBool32 VKAPI_PTR UserDebugReportCallback(VkDebugReportFlagsEXT flags,
+                                           VkDebugReportObjectTypeEXT objectType, uint64_t object,
+                                           size_t location, int32_t messageCode,
+                                           const char *pLayerPrefix, const char *pMessage,
+                                           void *pUserData)
+{
+  UserDebugReportCallbackData *user = (UserDebugReportCallbackData *)pUserData;
+
+  if(RenderDoc::Inst().GetCaptureOptions().debugOutputMute)
+  {
+    if(user->muteWarned)
+      return false;
+
+    // once only insert a fake message notifying of the muting
+    user->muteWarned = true;
+
+    // we insert as an information message, since some trigger-happy applications might
+    // debugbreak/crash/messagebox/etc on even warnings. This puts us in the same pool
+    // as extremely spammy messages, but there's not much alternative.
+    if(user->createInfo.flags & (VK_DEBUG_REPORT_INFORMATION_BIT_EXT | VK_DEBUG_REPORT_DEBUG_BIT_EXT))
+    {
+      // use information type if possible, or if it's not accepted but debug is - use debug type.
+      flags = (user->createInfo.flags & VK_DEBUG_REPORT_INFORMATION_BIT_EXT)
+                  ? VK_DEBUG_REPORT_INFORMATION_BIT_EXT
+                  : VK_DEBUG_REPORT_DEBUG_BIT_EXT;
+
+      user->createInfo.pfnCallback(flags, VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT,
+                                   (uint64_t)user->wrappedInstance, 1, 1, "RDOC",
+                                   "While debugging through RenderDoc, debug output through "
+                                   "validation layers is suppressed.\n"
+                                   "To show debug output look at the 'DebugOutputMute' capture "
+                                   "option in RenderDoc's API, but "
+                                   "be aware of false positives from the validation layers.",
+                                   user->createInfo.pUserData);
+    }
+
+    return false;
+  }
+
+  return user->createInfo.pfnCallback(flags, objectType, object, location, messageCode,
+                                      pLayerPrefix, pMessage, user->createInfo.pUserData);
+}
+
+VkBool32 VKAPI_PTR UserDebugUtilsCallback(VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity,
+                                          VkDebugUtilsMessageTypeFlagsEXT messageType,
+                                          const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData,
+                                          void *pUserData)
+{
+  UserDebugUtilsCallbackData *user = (UserDebugUtilsCallbackData *)pUserData;
+
+  if(RenderDoc::Inst().GetCaptureOptions().debugOutputMute)
+  {
+    if(user->muteWarned)
+      return false;
+
+    // once only insert a fake message notifying of the muting
+    user->muteWarned = true;
+
+    // we insert as an information message, since some trigger-happy applications might
+    // debugbreak/crash/messagebox/etc on even warnings. This puts us in the same pool
+    // as extremely spammy messages, but there's not much alternative.
+    if(user->createInfo.messageSeverity & (VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT |
+                                           VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT))
+    {
+      // use information type if possible, or if it's not accepted but debug is - use debug type.
+      messageSeverity =
+          (user->createInfo.messageSeverity & VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT)
+              ? VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT
+              : VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT;
+
+      VkDebugUtilsMessengerCallbackDataEXT data = {};
+
+      data.messageIdNumber = 1;
+      data.pMessageIdName = NULL;
+      data.pMessage =
+          "While debugging through RenderDoc, debug output through validation layers is "
+          "suppressed.\n"
+          "To show debug output look at the 'DebugOutputMute' capture option in RenderDoc's API, "
+          "but be aware of false positives from the validation layers.";
+      data.sType = VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT;
+
+      user->createInfo.pfnUserCallback(messageSeverity, VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT,
+                                       &data, user->createInfo.pUserData);
+    }
+
+    return false;
+  }
+
+  return user->createInfo.pfnUserCallback(messageSeverity, messageType, pCallbackData,
+                                          user->createInfo.pUserData);
+}
+
+VkResult WrappedVulkan::vkCreateDebugReportCallbackEXT(
+    VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo,
+    const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback)
+{
+  // we create an interception object here so that we can dynamically check the state of API
+  // messages being muted, since it's quite likely that the application will initialise Vulkan (and
+  // so create a debug report callback) before it messes with RenderDoc's API to unmute messages.
+  UserDebugReportCallbackData *user = new UserDebugReportCallbackData();
+  user->wrappedInstance = instance;
+  user->createInfo = *pCreateInfo;
+  user->muteWarned = false;
+
+  VkDebugReportCallbackCreateInfoEXT wrappedCreateInfo = *pCreateInfo;
+  wrappedCreateInfo.pfnCallback = &UserDebugReportCallback;
+  wrappedCreateInfo.pUserData = user;
+
+  VkResult vkr = ObjDisp(instance)->CreateDebugReportCallbackEXT(
+      Unwrap(instance), &wrappedCreateInfo, pAllocator, &user->realObject);
+
+  if(vkr != VK_SUCCESS)
+  {
+    *pCallback = VK_NULL_HANDLE;
+    delete user;
+    return vkr;
+  }
+
+  {
+    SCOPED_LOCK(m_CallbacksLock);
+    m_ReportCallbacks.push_back(user);
+  }
+
+  *pCallback = (VkDebugReportCallbackEXT)(uint64_t)user;
+
+  return vkr;
+}
+
+void WrappedVulkan::vkDestroyDebugReportCallbackEXT(VkInstance instance,
+                                                    VkDebugReportCallbackEXT callback,
+                                                    const VkAllocationCallbacks *pAllocator)
+{
+  if(callback == VK_NULL_HANDLE)
+    return;
+
+  UserDebugReportCallbackData *user =
+      (UserDebugReportCallbackData *)(uintptr_t)NON_DISP_TO_UINT64(callback);
+
+  ObjDisp(instance)->DestroyDebugReportCallbackEXT(Unwrap(instance), user->realObject, pAllocator);
+
+  {
+    SCOPED_LOCK(m_CallbacksLock);
+    m_ReportCallbacks.removeOne(user);
+  }
+
+  delete user;
+}
+
+void WrappedVulkan::vkDebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags,
+                                            VkDebugReportObjectTypeEXT objectType, uint64_t object,
+                                            size_t location, int32_t messageCode,
+                                            const char *pLayerPrefix, const char *pMessage)
+{
+  return ObjDisp(instance)->DebugReportMessageEXT(Unwrap(instance), flags, objectType, object,
+                                                  location, messageCode, pLayerPrefix, pMessage);
+}
+
+void WrappedVulkan::vkSetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount,
+                                        const VkSwapchainKHR *pSwapchains,
+                                        const VkHdrMetadataEXT *pMetadata)
+{
+  return ObjDisp(device)->SetHdrMetadataEXT(Unwrap(device), swapchainCount,
+                                            UnwrapArray(pSwapchains, swapchainCount), pMetadata);
+}
+
+void WrappedVulkan::vkSetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain,
+                                         VkBool32 localDimmingEnable)
+{
+  return ObjDisp(device)->SetLocalDimmingAMD(Unwrap(device), Unwrap(swapChain), localDimmingEnable);
+}
+
+// we use VkObjectType as the object type since it mostly overlaps with the debug report enum so in
+// most cases we can upcast it. There's an overload to translate the few that might conflict.
+// Likewise to re-use the switch in most cases, we return both the record and the unwrapped
+// object at once. In *most* cases the unwrapped object comes from the record, but there are a few
+// exceptions which don't have records, or aren't wrapped, etc.
+struct ObjData
+{
+  VkResourceRecord *record;
+  uint64_t unwrapped;
+};
+
+static ObjData GetObjData(VkObjectType objType, uint64_t object)
+{
+  ObjData ret = {};
+
+  switch(objType)
+  {
+    case VK_OBJECT_TYPE_INSTANCE: ret.record = GetRecord((VkInstance)object); break;
+    case VK_OBJECT_TYPE_PHYSICAL_DEVICE: ret.record = GetRecord((VkPhysicalDevice)object); break;
+    case VK_OBJECT_TYPE_DEVICE: ret.record = GetRecord((VkDevice)object); break;
+    case VK_OBJECT_TYPE_QUEUE: ret.record = GetRecord((VkQueue)object); break;
+    case VK_OBJECT_TYPE_SEMAPHORE: ret.record = GetRecord((VkSemaphore)object); break;
     case VK_OBJECT_TYPE_COMMAND_BUFFER: ret.record = GetRecord((VkCommandBuffer)object); break;
     case VK_OBJECT_TYPE_FENCE: ret.record = GetRecord((VkFence)object); break;
     case VK_OBJECT_TYPE_DEVICE_MEMORY: ret.record = GetRecord((VkDeviceMemory)object); break;
@@ -2052,11 +3034,17 @@ static ObjData GetObjData(VkObjectType objType, uint64_t object)
       ret.unwrapped = object;
       break;
 
-    // these objects are not supported
     case VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR:
+      ret.record = GetRecord((VkAccelerationStructureKHR)object);
+      break;    
+    
+    case VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR:
+      ret.record = GetRecord((VkDeferredOperationKHR)object);
+      break;    
+    // these objects are not supported
     case VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV:
     case VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL:
-    case VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR:
+
     case VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV:
     case VK_OBJECT_TYPE_CU_MODULE_NVX:
     case VK_OBJECT_TYPE_CU_FUNCTION_NVX:
@@ -2124,7 +3112,9 @@ static ObjData GetObjData(VkDebugReportObjectTypeEXT objType, uint64_t object)
   else if(objType == VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT)
     castType = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE;
   else if(objType == VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT)
-    castType = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR;
+    castType = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR;  
+  else if(objType == VK_DEBUG_REPORT_OBJECT_TYPE_DEFERRED_OPERATION_KHR)
+    castType = VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR;
   else if(objType == VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT)
     castType = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV;
   else if(objType == VK_DEBUG_REPORT_OBJECT_TYPE_CU_MODULE_NVX_EXT)
@@ -2132,7 +3122,7 @@ static ObjData GetObjData(VkDebugReportObjectTypeEXT objType, uint64_t object)
   else if(objType == VK_DEBUG_REPORT_OBJECT_TYPE_CU_FUNCTION_NVX_EXT)
     castType = VK_OBJECT_TYPE_CU_FUNCTION_NVX;
   else if(objType == VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT)
-    castType = VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA;
+    castType = VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA; 
 
   return GetObjData(castType, object);
 }
@@ -2275,6 +3265,14 @@ bool WrappedVulkan::Serialise_vkDebugMarkerSetObjectNameEXT(
         case eResSamplerConversion:
           type = VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT;
           break;
+        //raytracing
+        case eResAccelerationStructure:
+          type = VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT;
+          break;        
+        case eResDeferredOperation:
+          type = VK_DEBUG_REPORT_OBJECT_TYPE_DEFERRED_OPERATION_KHR;
+          break;        
+
       }
 
       if(ObjDisp(m_Device)->DebugMarkerSetObjectNameEXT &&
@@ -2464,6 +3462,8 @@ bool WrappedVulkan::Serialise_vkSetDebugUtilsObjectNameEXT(
         case eResSurface: type = VK_OBJECT_TYPE_SURFACE_KHR; break;
         case eResDescUpdateTemplate: type = VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE; break;
         case eResSamplerConversion: type = VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION; break;
+        case eResAccelerationStructure: type = VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR; break;
+        case eResDeferredOperation: type = VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR; break;
       }
 
       if(ObjDisp(m_Device)->SetDebugUtilsObjectNameEXT && type != VK_OBJECT_TYPE_UNKNOWN &&
@@ -2662,5 +3662,10 @@ INSTANTIATE_FUNCTION_SERIALISED(VkResult, vkCreateSamplerYcbcrConversion, VkDevi
                                 const VkAllocationCallbacks *pAllocator,
                                 VkSamplerYcbcrConversion *pYcbcrConversion);
 
+INSTANTIATE_FUNCTION_SERIALISED(VkResult, vkCreateAccelerationStructureKHR, VkDevice device,
+                                const VkAccelerationStructureCreateInfoKHR *pCreateInfo,
+                                const VkAllocationCallbacks *pAllocator,
+                                VkAccelerationStructureKHR *pAccelerationStructure);
+
 INSTANTIATE_FUNCTION_SERIALISED(VkResult, vkResetQueryPool, VkDevice device, VkQueryPool queryPool,
                                 uint32_t firstQuery, uint32_t queryCount);
diff --git a/renderdoc/renderdoc.vcxproj b/renderdoc/renderdoc.vcxproj
index 401fceb04..15a76f457 100644
--- a/renderdoc/renderdoc.vcxproj
+++ b/renderdoc/renderdoc.vcxproj
@@ -24,6 +24,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoc</RootNamespace>
     <ProjectName>renderdoc</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -31,7 +32,7 @@
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Release'" Label="Configuration">
     <LinkIncremental>false</LinkIncremental>
diff --git a/renderdoc/renderdoc_version.vcxproj b/renderdoc/renderdoc_version.vcxproj
index f41b6f668..0e1e90a9f 100644
--- a/renderdoc/renderdoc_version.vcxproj
+++ b/renderdoc/renderdoc_version.vcxproj
@@ -23,13 +23,14 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>version</RootNamespace>
     <ProjectName>version</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup>
     <ConfigurationType>StaticLibrary</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
     <CharacterSet>Unicode</CharacterSet>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
@@ -67,9 +68,11 @@
     <LibGit2SharpPath>$([MSBuild]::Unescape("$(DevEnvDir)\CommonExtensions\Microsoft\TeamFoundation\Team Explorer\LibGit2Sharp.dll"))</LibGit2SharpPath>
     <LibGit2SharpPath Condition="!exists('$(LibGit2SharpPath)')">$([MSBuild]::Unescape("$(VSInstallDir)\Common7\IDE\CommonExtensions\Microsoft\TeamFoundation\Team Explorer\LibGit2Sharp.dll"))</LibGit2SharpPath>
     <!-- if the path still doesn't work, unset and we'll do manual ref lookups instead -->
-    <LibGit2SharpPath Condition="!exists('$(LibGit2SharpPath)')"></LibGit2SharpPath>
+    <LibGit2SharpPath Condition="!exists('$(LibGit2SharpPath)')">
+    </LibGit2SharpPath>
     <!-- on MSBuild 17 (VS2022 and up) the LibGit2Sharp.dll can't load its git dll because of architecture mismatches, so do manual ref lookups -->
-    <LibGit2SharpPath Condition="'$(MSBuildVersion.Length)' > 0 And '$(MSBuildVersion.Substring(0,2))' >= 17"></LibGit2SharpPath>
+    <LibGit2SharpPath Condition="'$(MSBuildVersion.Length)' &gt; 0 And '$(MSBuildVersion.Substring(0,2))' &gt;= 17">
+    </LibGit2SharpPath>
   </PropertyGroup>
   <!-- Declare the task with some inline code -->
   <UsingTask TaskName="GetGitCommitDotNet" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
@@ -80,8 +83,7 @@
     </ParameterGroup>
     <Task>
       <Reference Include="$(LibGit2SharpPath)" />
-      <Code Type="Class" Language="cs">
-<![CDATA[
+      <Code Type="Class" Language="cs"><![CDATA[
 using System;
 using System.Linq;
 using System.Runtime.CompilerServices;
@@ -110,8 +112,7 @@ namespace GitIntrospection {
     [Microsoft.Build.Framework.Output] public string Sha1 { get; set; }
   }
 }
-]]>
-      </Code>
+]]></Code>
     </Task>
   </UsingTask>
   <UsingTask TaskName="GetGitCommitManual" TaskFactory="CodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
@@ -120,8 +121,7 @@ namespace GitIntrospection {
       <Repository ParameterType="System.String" Required="True" Output="False" />
     </ParameterGroup>
     <Task>
-      <Code Type="Class" Language="cs">
-<![CDATA[
+      <Code Type="Class" Language="cs"><![CDATA[
 using System;
 using System.IO;
 
@@ -150,11 +150,12 @@ namespace GitIntrospection {
     [Microsoft.Build.Framework.Output] public string Sha1 { get; set; }
   }
 }
-]]>
-      </Code>
+]]></Code>
     </Task>
   </UsingTask>
-  <PropertyGroup><DisableFastUpToDateCheck>true</DisableFastUpToDateCheck></PropertyGroup>
+  <PropertyGroup>
+    <DisableFastUpToDateCheck>true</DisableFastUpToDateCheck>
+  </PropertyGroup>
   <!-- Only actually run the task if we located the assembly for LibGit2Sharp. Otherwise silently skip this step. -->
   <Target Name="RunTaskDotNet" BeforeTargets="PrepareForBuild" Condition="exists('$(LibGit2SharpPath)')">
     <GetGitCommitDotNet Repository="$(SolutionDir)" LibGit2SharpAssemblyPath="$(LibGit2SharpPath)" ContinueOnError="WarnAndContinue">
diff --git a/renderdoccmd/renderdoccmd.vcxproj b/renderdoccmd/renderdoccmd.vcxproj
index 4d2c870fe..b9e7a6b92 100644
--- a/renderdoccmd/renderdoccmd.vcxproj
+++ b/renderdoccmd/renderdoccmd.vcxproj
@@ -23,6 +23,7 @@
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdoccmd</RootNamespace>
     <ProjectName>renderdoccmd</ProjectName>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -30,27 +31,27 @@
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Development|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
     <ConfigurationType>Application</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
diff --git a/renderdocshim/renderdocshim.vcxproj b/renderdocshim/renderdocshim.vcxproj
index d86029edb..105d8e3a4 100644
--- a/renderdocshim/renderdocshim.vcxproj
+++ b/renderdocshim/renderdocshim.vcxproj
@@ -22,6 +22,7 @@
     <ProjectGuid>{6DEE3F12-F2F8-42CA-865A-578D0FD11387}</ProjectGuid>
     <Keyword>Win32Proj</Keyword>
     <RootNamespace>renderdocshim</RootNamespace>
+    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(SolutionDir)\util\WindowsSDKTarget.props" />
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
@@ -29,27 +30,27 @@
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Development|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>true</UseDebugLibraries>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
     <UseDebugLibraries>false</UseDebugLibraries>
     <WholeProgramOptimization>true</WholeProgramOptimization>
     <CharacterSet>Unicode</CharacterSet>
-    <PlatformToolset>v140</PlatformToolset>
+    <PlatformToolset>v143</PlatformToolset>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
   <ImportGroup Label="ExtensionSettings">
-- 
2.41.0.windows.2

